{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"controllers/","text":"Available Controllers Controllers in laminas-mvc are objects implementing Laminas\\Stdlib\\DispatchableInterface . That interface describes a single method: use Laminas\\Stdlib\\DispatchableInterface; use Laminas\\Stdlib\\RequestInterface as Request; use Laminas\\Stdlib\\ResponseInterface as Response; class EditProductController implements DispatchableInterface { public function dispatch(Request $request, Response $response = null) { // ... do something, and preferably return a Response ... } } This approach allows you to handle only one type of request per class. This can help keep classes small. If you wish to handle multiple types of requests per class, there are several abstract controllers that you can extend: AbstractActionController AbstractRestfulController To provide convenience, laminas-mvc also defines several interfaces that, when implemented, can provide controllers with additional capabilities. Common Interfaces Used With Controllers InjectApplicationEvent The Laminas\\Mvc\\InjectApplicationEventInterface hints to the Application instance that it should inject its MvcEvent into the controller itself. Why would this be useful? Recall that the MvcEvent composes a number of objects: the Request and Response , naturally, but also the router, the route matches (a RouteMatch instance), and potentially the \"result\" of dispatching. A controller that has the MvcEvent injected, then, can retrieve or inject these. As an example: $matches = $this-&gt;getEvent()-&gt;getRouteMatch(); $id = $matches-&gt;getParam('id', false); if (! $id) { $response = $this-&gt;getResponse(); $response-&gt;setStatusCode(500); $this-&gt;getEvent()-&gt;setResult('Invalid identifier; cannot complete request'); return; } The InjectApplicationEventInterface defines two methods: public function setEvent(Laminas\\EventManager\\EventInterface $event); public function getEvent(); ServiceLocatorAware In most cases, you should define your controllers such that dependencies are injected by the application's ServiceManager , via either constructor arguments or setter methods. However, occasionally you may have objects you wish to use in your controller that are only valid for certain code paths. Examples include forms, paginators, navigation, etc. In these cases, you may decide that it doesn't make sense to inject those objects every time the controller is used. The ServiceLocatorAwareInterface interface hints to the ServiceManager that it should inject itself into the controller. It defines two simple methods: use Laminas\\ServiceManager\\ServiceLocatorInterface; use Laminas\\ServiceManager\\ServiceLocatorAwareInterface; public function setServiceLocator(ServiceLocatorInterface $serviceLocator); public function getServiceLocator(); ServiceLocatorInterface is deprecated ServiceLocatorAwareInterface was removed from laminas-servicemanager v3.0 , and, as such, starting in laminas-mvc 2.7.0, the AbstractController implementation no longer implements the interface, though it implements the methods the interface defines; this allows forwards compatibility with laminas-servicemanager v3. However, also starting with the laminas-mvc 2.7.0 release, ServiceLocatorAwareInterface usage is deprecated. We recommend injecting dependencies explicitly instead of pulling them from a composed ServiceManager instance. In cases where an object will not be used in all code paths, we recommend splitting into discrete controllers, or using lazy services . EventManagerAware Typically, it's nice to be able to tie into a controller's workflow without needing to extend it or hardcode behavior into it. The solution for this is to use the EventManager . You can hint to the ServiceManager that you want an EventManager injected by implementing the interface EventManagerAwareInterface , which tells the ServiceManager to inject an EventManager . To do this, you define two methods. The first, a setter, should also set any SharedEventManager identifiers you want to listen on, and the second, a getter, should return the composed EventManager instance. use Laminas\\EventManager\\EventManagerAwareInterface; use Laminas\\EventManager\\EventManagerInterface; public function setEventManager(EventManagerInterface $events); public function getEventManager(); Controller Plugins Code re-use is a common goal for developers. Another common goal is convenience. However, this is often difficult to achieve cleanly in abstract, general systems. Within your controllers, you'll often find yourself repeating tasks from one controller to another. Some common examples: Generating URLs. Redirecting. Setting and retrieving flash messages (self-expiring session messages). Invoking and dispatching additional controllers. To facilitate these actions while also making them available to alternate controller implementations, we've created a PluginManager implementation for the controller layer, Laminas\\Mvc\\Controller\\PluginManager , building on the Laminas\\ServiceManager\\AbstractPluginManager functionality. To utilize it, implement the setPluginManager(PluginManager $plugins) method, and set up your code to use the controller-specific implementation by default: use Laminas\\Mvc\\Controller\\PluginManager; public function setPluginManager(PluginManager $plugins) { $this-&gt;plugins = $plugins; $this-&gt;plugins-&gt;setController($this); return $this; } public function getPluginManager() { if (!$this-&gt;plugins) { $this-&gt;setPluginManager(new PluginManager()); } return $this-&gt;plugins; } public function plugin($name, array $options = null) { return $this-&gt;getPluginManager()-&gt;get($name, $options); } AbstractActionController Implementing each of the above interfaces is a lesson in redundancy; you won't often want to do it. As such, we've developed abstract, base controllers you can extend to get started. The first is Laminas\\Mvc\\Controller\\AbstractActionController . This controller implements each of the above interfaces, and uses the following assumptions: An \"action\" parameter is expected in the RouteMatch object composed in the attached MvcEvent . If none is found, a notFoundAction() is invoked. The \"action\" parameter is converted to a camelCased format and appended with the word \"Action\" to create a method name. As examples: \"foo\" maps to fooAction , \"foo-bar\" or \"foo.bar\" or \"foo_bar\" to fooBarAction . The controller then checks to see if that method exists. If not, the notFoundAction() method is invoked; otherwise, the discovered method is called. The results of executing the given action method are injected into the MvcEvent 's \"result\" property (via setResult() , and accessible via getResult() ). Essentially, a route mapping to an AbstractActionController needs to return both the \"controller\" and \"action\" keys in its matches. Creation of action controllers looks like the following example: namespace Foo\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; class BarController extends AbstractActionController { public function bazAction() { return ['title' =&gt; __METHOD__]; } public function batAction() { return ['title' =&gt; __METHOD__]; } } Interfaces and Collaborators AbstractActionController implements each of the following interfaces: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\InjectApplicationEventInterface Laminas\\ServiceManager\\ServiceLocatorAwareInterface (starting with laminas-mvc 2.7.0, only the methods defined by the interface, not the interface itself) Laminas\\EventManager\\EventManagerAwareInterface The composed EventManager will be configured to listen on the following contexts: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\Controller\\AbstractActionController Laminas\\Mvc\\Controller\\AbstractController Additionally, if you extend the class, it will listen on the name of the extending class. AbstractRestfulController Laminas\\Mvc\\Controller\\AbstractRestfulController provides a native RESTful implementation that maps HTTP request methods to controller methods, using the following matrix: GET maps to either get() or getList() , depending on whether or not an \"id\" parameter is found in the route matches. If one is, it is passed as an argument to get() ; if not, getList() is invoked. In the former case, you should provide a representation of the given entity with that identification; in the latter, you should provide a list of entities. POST maps to create() . That method expects a $data argument, usually the $_POST superglobal array. The data should be used to create a new entity, and the response should typically be an HTTP 201 response with the Location header indicating the URI of the newly created entity and the response body providing the representation. PUT maps to update() , and requires that an \"id\" parameter exists in the route matches; that value is passed as an argument to the method. It should attempt to update the given entity, and, if successful, return either a 200 or 202 response status, as well as the representation of the entity. DELETE maps to delete() , and requires that an \"id\" parameter exists in the route matches; that value is passed as an argument to the method. It should attempt to delete the given entity, and, if successful, return either a 200 or 204 response status. Additionally, you can map \"action\" methods to the AbstractRestfulController , just as you would in the AbstractActionController ; these methods will be suffixed with \"Action\", differentiating them from the RESTful methods listed above. This allows you to perform such actions as providing forms used to submit to the various RESTful methods, or to add RPC methods to your RESTful API. Interfaces and Collaborators AbstractRestfulController implements each of the following interfaces: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\InjectApplicationEventInterface Laminas\\ServiceManager\\ServiceLocatorAwareInterface (starting with laminas-mvc 2.7.0, only the methods defined by the interface, not the interface itself) Laminas\\EventManager\\EventManagerAwareInterface The composed EventManager will be configured to listen on the following contexts: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\Controller\\AbstractRestfulController Laminas\\Mvc\\Controller\\AbstractController Additionally, if you extend the class, it will listen on the name of the extending class. Interfaces and Collaborators AbstractRestfulController implements each of the following interfaces: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\InjectApplicationEventInterface Laminas\\ServiceManager\\ServiceLocatorAwareInterface (starting with laminas-mvc 2.7.0, only the methods defined by the interface, not the interface itself) Laminas\\EventManager\\EventManagerAwareInterface The composed EventManager will be configured to listen on the following contexts: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\Controller\\AbstractActionController Laminas\\Mvc\\Controller\\AbstractController Additionally, if you extend the class, it will listen on the name of the extending class.","title":"Available Controllers"},{"location":"controllers/#available-controllers","text":"Controllers in laminas-mvc are objects implementing Laminas\\Stdlib\\DispatchableInterface . That interface describes a single method: use Laminas\\Stdlib\\DispatchableInterface; use Laminas\\Stdlib\\RequestInterface as Request; use Laminas\\Stdlib\\ResponseInterface as Response; class EditProductController implements DispatchableInterface { public function dispatch(Request $request, Response $response = null) { // ... do something, and preferably return a Response ... } } This approach allows you to handle only one type of request per class. This can help keep classes small. If you wish to handle multiple types of requests per class, there are several abstract controllers that you can extend: AbstractActionController AbstractRestfulController To provide convenience, laminas-mvc also defines several interfaces that, when implemented, can provide controllers with additional capabilities.","title":"Available Controllers"},{"location":"controllers/#common-interfaces-used-with-controllers","text":"","title":"Common Interfaces Used With Controllers"},{"location":"controllers/#abstractactioncontroller","text":"Implementing each of the above interfaces is a lesson in redundancy; you won't often want to do it. As such, we've developed abstract, base controllers you can extend to get started. The first is Laminas\\Mvc\\Controller\\AbstractActionController . This controller implements each of the above interfaces, and uses the following assumptions: An \"action\" parameter is expected in the RouteMatch object composed in the attached MvcEvent . If none is found, a notFoundAction() is invoked. The \"action\" parameter is converted to a camelCased format and appended with the word \"Action\" to create a method name. As examples: \"foo\" maps to fooAction , \"foo-bar\" or \"foo.bar\" or \"foo_bar\" to fooBarAction . The controller then checks to see if that method exists. If not, the notFoundAction() method is invoked; otherwise, the discovered method is called. The results of executing the given action method are injected into the MvcEvent 's \"result\" property (via setResult() , and accessible via getResult() ). Essentially, a route mapping to an AbstractActionController needs to return both the \"controller\" and \"action\" keys in its matches. Creation of action controllers looks like the following example: namespace Foo\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; class BarController extends AbstractActionController { public function bazAction() { return ['title' =&gt; __METHOD__]; } public function batAction() { return ['title' =&gt; __METHOD__]; } }","title":"AbstractActionController"},{"location":"controllers/#abstractrestfulcontroller","text":"Laminas\\Mvc\\Controller\\AbstractRestfulController provides a native RESTful implementation that maps HTTP request methods to controller methods, using the following matrix: GET maps to either get() or getList() , depending on whether or not an \"id\" parameter is found in the route matches. If one is, it is passed as an argument to get() ; if not, getList() is invoked. In the former case, you should provide a representation of the given entity with that identification; in the latter, you should provide a list of entities. POST maps to create() . That method expects a $data argument, usually the $_POST superglobal array. The data should be used to create a new entity, and the response should typically be an HTTP 201 response with the Location header indicating the URI of the newly created entity and the response body providing the representation. PUT maps to update() , and requires that an \"id\" parameter exists in the route matches; that value is passed as an argument to the method. It should attempt to update the given entity, and, if successful, return either a 200 or 202 response status, as well as the representation of the entity. DELETE maps to delete() , and requires that an \"id\" parameter exists in the route matches; that value is passed as an argument to the method. It should attempt to delete the given entity, and, if successful, return either a 200 or 204 response status. Additionally, you can map \"action\" methods to the AbstractRestfulController , just as you would in the AbstractActionController ; these methods will be suffixed with \"Action\", differentiating them from the RESTful methods listed above. This allows you to perform such actions as providing forms used to submit to the various RESTful methods, or to add RPC methods to your RESTful API.","title":"AbstractRestfulController"},{"location":"examples/","text":"Examples Controllers Accessing the Request and Response When using one of the abstract controller implementations, the request and response object are composed directly into the controller as soon as dispatch() is called. You may access them as follows: // Using explicit accessor methods $request = $this-&gt;getRequest(); $response = $this-&gt;getResponse(); // Using direct property access $request = $this-&gt;request; $response = $this-&gt;response; Additionally, if your controller implements InjectApplicationEventInterface (as all shipped abstract controllers do), you can access these objects from the attached MvcEvent : $event = $this-&gt;getEvent(); $request = $event-&gt;getRequest(); $response = $event-&gt;getResponse(); The above can be useful when composing event listeners into your controller. Accessing routing parameters The parameters returned when routing completes are wrapped in a Laminas\\Router\\RouteMatch object. This object is detailed in the section on Routing . Within your controller, if you implement InjectApplicationEventInterface (as all shipped abstract controllers do), you can access this object from the attached MvcEvent : $event = $this-&gt;getEvent(); $matches = $event-&gt;getRouteMatch(); Once you have the RouteMatch object, you can pull parameters from it. The same can be done using the Params plugin . Returning early You can short-circuit execution of the application at any point by returning a Response from your controller or any event. When such a value is discovered, it halts further execution of the event manager, bubbling up to the Application instance, where it is immediately returned. As an example, the Redirect plugin returns a Response , which can be returned immediately so as to complete the request as quickly as possible. Other use cases might be for returning JSON or XML results from web service endpoints, returning \"401 Unauthorized\" results, etc. Bootstrapping Registering module-specific listeners You may want module-specific listeners; these allow you to introduce authorization, logging, caching, or other concerns into your application. Each Module class can have an optional onBootstrap() method. This method is used for module-specific configuration, and is the ideal location to setup event listeners for you module. The onBootstrap() method is called for every module on every page request and should only be used for performing lightweight tasks such as registering event listeners. The base Application class shipped with the framework has an EventManager associated with it, and once the modules are initialized, it triggers the bootstrap event, which provides a getApplication() method on the event. One way to accomplish module-specific listeners is to listen to that event, and register listeners at that time. As an example: namespace SomeCustomModule; class Module { /** * @param \\Laminas\\Mvc\\MvcEvent $e The MvcEvent instance * @return void */ public function onBootstrap($e) { $application = $e-&gt;getApplication(); $config = $application-&gt;getConfig(); $view = $application-&gt;getServiceManager()-&gt;get('ViewHelperManager'); // You must have these keys in you application config $view-&gt;headTitle($config['view']['base_title']); // This is your custom listener $listener = new Listeners\\ViewListener(); $listener-&gt;setView($view); $listener-&gt;attach($application-&gt;getEventManager()); } } The above demonstrates several things. First, it demonstrates a listener on the application's bootstrap event (the onBootstrap() method). Second, it demonstrates that listener, and how it can be used to register listeners with the application. It grabs the Application instance; from the Application , it is able to grab the attached service manager and configuration. These are then used to retrieve the view, configure some helpers, and then register a listener aggregate with the application event manager.","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#controllers","text":"","title":"Controllers"},{"location":"examples/#bootstrapping","text":"","title":"Bootstrapping"},{"location":"intro/","text":"Introduction laminas-mvc is the MVC layer shipped with Laminas and above, and focuses on performance and flexibility. The MVC layer is built on top of the following components: laminas-servicemanager - laminas-mvc provides a set of default service definitions, used to create and configure the application instance and workflow. laminas-eventmanager - The MVC is event driven, and uses events for the initial bootstrapping of the application, for returning response and request calls, for matching routes, and even for rendering views. laminas-http - specifically the request and response objects from the Laminas\\Http\\PhpEnvironment namespace, which provide objects that ensure the request is injected with the current environment (including query parameters, POST parameters, HTTP headers, etc.), and that the response will interact correctly with the SAPI and output buffering. laminas-stdlib - specifically Laminas\\Stdlib\\DispatchableInterface . All \"controllers\" are simply dispatchable objects. laminas-router - provides routing of a request. In other words, it matches the request to its respective controller (or dispatchable). Within the MVC layer, several sub-components are exposed: Laminas\\Mvc\\Controller , a set of abstract \"controller\" classes with basic responsibilities such as event wiring, action dispatching, etc., as well as controller plugins. Laminas\\Mvc\\Service provides a set of laminas-servicemanager factories and definitions for the default application workflow. Laminas\\Mvc\\View provides default wiring for renderer selection, view script resolution, helper registration, and more; additionally, it provides a number of listeners that tie into the MVC workflow, providing features such as automated template name resolution, automated view model creation and injection, etc. The gateway to the MVC is the Laminas\\Mvc\\Application object (referred to as Application henceforth). Its primary responsibilities are to bootstrap resources, to route the request, and to retrieve and dispatch the controller matched during routing. Once accomplished, it will render the view, and finish the request, returning and sending the response. Basic Application Structure The basic application structure follows: application_root/ config/ application.config.php autoload/ global.php local.php // etc. data/ module/ vendor/ public/ .htaccess index.php The public/index.php script marshals all user requests to your website, retrieving an array of configuration from config/application.config.php . On return, it run() s the Application , processing the request and returning a response to the user. The config directory as described above contains configuration used by laminas-modulemanager to load modules and merge configuration (e.g., database configuration and credentials); we will detail this more later. The vendor sub-directory should contain any third-party modules or libraries on which your application depends. This might include Laminas, custom libraries from your organization, or other third-party libraries from other projects. Libraries and modules placed in the vendor sub-directory should not be modified from their original, distributed state. Typically, this directory will be managed by Composer . Finally, the module directory will contain one or more modules delivering your application's functionality. Let's now turn to modules, as they are the basic units of a web application. Basic Module Structure A module may contain anything: PHP code, including MVC functionality; library code; view scripts; and/or or public assets such as images, CSS, and JavaScript. The only requirement — and even this is optional — is that a module acts as a PHP namespace and that it contains a Module class under that namespace. This class is eventually consumed by laminas-modulemanager to perform a number of tasks. The recommended module structure follows: module_root&lt;named-after-module-namespace&gt;/ Module.php autoload_classmap.php autoload_function.php autoload_register.php config/ module.config.php public/ images/ css/ js/ src/ &lt;module_namespace&gt;/ &lt;code files&gt; test/ phpunit.xml bootstrap.php &lt;module_namespace&gt;/ &lt;test code files&gt; view/ &lt;dir-named-after-module-namespace&gt;/ &lt;dir-named-after-a-controller&gt;/ &lt;.phtml files&gt; Since a module acts as a namespace, the module root directory should be that namespace. This namespace could also include a vendor prefix of sorts. As an example a module centered around \"User\" functionality delivered by Laminas might be named \"LaminasUser\", and this is also what the module root directory will be named. Source and test code organization The above details a PSR-0 structure for the source and test code directories. You can also use PSR-4 so long as you have setup autoloading correctly to do so. The Module.php file directly under the module root directory will be in the module namespace shown below. namespace LaminasUser; class Module { } Module class location If you have an autoloader defined, such as detailed later around the various autoload_*.php files or using Composer's autoloading features , then your Module.php file can be co-located with your source code. Our current recommendation is to define autoloading for your application-specific modules via Composer. When an init() method is defined, this method will be triggered by a laminas-modulemanager listener when it loads the module class, and passed a ModuleManager instance by default. This allows you to perform tasks such as setting up module-specific event listeners. But be cautious, the init() method is called for every module on every page request and should only be used for performing lightweight tasks such as registering event listeners. Similarly, an onBootstrap() method (which accepts an MvcEvent instance) may be defined; it is also triggered for every page request, and should be used for lightweight tasks as well. The three autoload_*.php files are not required, but recommended if you are not using Composer to provide autoloading for your module. They provide the following: File Description autoload_classmap.php Should return an array classmap of class name/filename pairs (with the filenames resolved via the __DIR__ magic constant). autoload_function.php Should return a PHP callback that can be passed to spl_autoload_register() . Typically, this callback should utilize the map returned by autoload_classmap.php. autoload_register.php should register a PHP callback (is typically returned by autoload_function.php with spl_autoload_register() . The point of these three files is to provide reasonable default mechanisms for autoloading the classes contained in the module, thus providing a trivial way to consume the module without requiring laminas-modulemanager (e.g., for use outside a Laminas application). The config directory should contain any module-specific configuration. These files may be in any format laminas-config supports. We recommend naming the main configuration module.config.&lt;format&gt; (e.g., for PHP-based configuration, module.config.php ). Typically, you will create configuration for the router as well as for the service manager. The src directory should be a PSR-0 or PSR-4 compliant directory structure with your module's source code. The test directory should contain your unit tests. Typically, these are written using PHPUnit . The public directory can be used for assets that you may want to expose in your application's document root. These might include images, CSS files, JavaScript files, etc. How these are exposed is left to the developer. The view directory contains view scripts related to your controllers. Bootstrapping an Application The Application has seven basic dependencies. configuration , usually an array or object implementing Traversable . ServiceManager instance. EventManager instance, which, by default, is pulled from the ServiceManager , by the service name \"EventManager\". SharedEventManager instance, which, by default, is pulled from the ServiceManager , by the service name \"SharedEventManager\"; this is injected into the EventManager instance, and then pushed into every new EventManager instance created. ModuleManager instance, which, by default, is pulled from the ServiceManager , by the service name \"ModuleManager\". Request instance, which, by default, is pulled from the ServiceManager , by the service name \"Request\". Response instance, which, by default, is pulled from the ServiceManager , by the service name \"Response\". These may be satisfied at instantiation: use Laminas\\EventManager\\EventManager; use Laminas\\EventManager\\SharedEventManager; use Laminas\\Http\\PhpEnvironment; use Laminas\\ModuleManager\\ModuleManager; use Laminas\\Mvc\\Application; use Laminas\\ServiceManager\\ServiceManager; $config = include 'config/application.config.php'; $serviceManager = new ServiceManager(); $serviceManager-&gt;setService('SharedEventManager', new SharedEventManager()); $serviceManager-&gt;setService('ModuleManager', new ModuleManager($config)); $serviceManager-&gt;setService('Request', new PhpEnvironment\\Request()); $serviceManager-&gt;setService('Response', new PhpEnvironment\\Response()); $serviceManager-&gt;setFactory('EventManager', function ($serviceManager) { return new EventManager($serviceManager-&gt;get('SharedEventManager')); }); $serviceManager-&gt;setShared('EventManager', false); $application = new Application($config, $serviceManager); Once you've done this, there are two additional actions you can take. The first is to \"bootstrap\" the application. In the default implementation, this does the following: Attaches the default route listener ( Laminas\\Mvc\\RouteListener ). Attaches the middleware dispatch listener ( Laminas\\Mvc\\MiddlewareListener ) (v2.7.0 and up). Attaches the default dispatch listener ( Laminas\\Mvc\\DispatchListener ). Attaches the ViewManager listener ( Laminas\\Mvc\\View\\ViewManager ). Creates the MvcEvent , and injects it with the application, request, and response; it also retrieves the router ( Laminas\\Router\\Http\\TreeRouteStack ) at this time and attaches it to the event. Triggers the \"bootstrap\" event. If you do not want these actions, or want to provide alternatives, you can do so by extending the Application class and/or manually coding what actions you want to occur. The second action you can take with the configured Application is to run() it. Calling this method performs the following: it triggers the \"route\" event, followed by the \"dispatch\" event, and, depending on execution, the \"render\" event When done, it triggers the \"finish\" event, and then returns the response instance. If an error occurs during either the \"route\" or \"dispatch\" event, a \"dispatch.error\" event is triggered as well. This is a lot to remember in order to bootstrap the application; in fact, we haven't covered all the services available by default yet. You can greatly simplify things by using the default ServiceManager configuration shipped with the MVC. use Laminas\\Loader\\AutoloaderFactory; use Laminas\\Mvc\\Service\\ServiceManagerConfig; use Laminas\\ServiceManager\\ServiceManager; // setup autoloader AutoloaderFactory::factory(); // get application stack configuration $configuration = include 'config/application.config.php'; // setup service manager $serviceManager = new ServiceManager(new ServiceManagerConfig()); $serviceManager-&gt;setService('ApplicationConfig', $configuration); // load modules -- which will provide services, configuration, and more $serviceManager-&gt;get('ModuleManager')-&gt;loadModules(); // bootstrap and run application $application = $serviceManager-&gt;get('Application'); $application-&gt;bootstrap(); $application-&gt;run(); You can make this even simpler by using the init() method of the Application . This is a static method for quick and easy initialization of the Application instance. use Laminas\\Loader\\AutoloaderFactory; use Laminas\\Mvc\\Application; use Laminas\\Mvc\\Service\\ServiceManagerConfig; use Laminas\\ServiceManager\\ServiceManager; // setup autoloader AutoloaderFactory::factory(); // get application stack configuration $configuration = include 'config/application.config.php'; // The init() method does something very similar with the previous example. Application::init($configuration)-&gt;run(); The init() does the following: Grabs the application configuration and pulls from the service_manager key, creating a ServiceManager instance with it and with the default services shipped with laminas-mvc; Creates a service named ApplicationConfig with the application configuration array; Grabs the ModuleManager service and loads the modules; bootstrap() s the Application and returns its instance. ApplicationConfig service If you use the init() method, you cannot specify a service with the name of 'ApplicationConfig' in your service manager config. This name is reserved to hold the array from application.config.php . The following services can only be overridden from application.config.php : ModuleManager SharedEventManager EventManager and Laminas\\EventManager\\EventManagerInterface All other services are configured after module loading, thus can be overridden by modules. You'll note that you have a great amount of control over the workflow. Using the ServiceManager , you have fine-grained control over what services are available, how they are instantiated, and what dependencies are injected into them. Using the EventManager 's priority system, you can intercept any of the application events (\"bootstrap\", \"route\", \"dispatch\", \"dispatch.error\", \"render\", and \"finish\") anywhere during execution, allowing you to craft your own application workflows as needed. Bootstrapping a Modular Application While the previous approach largely works, where does the configuration come from? When we create a modular application, the assumption will be that it's from the modules themselves. How do we get that information and aggregate it, then? The answer is via laminas-modulemanager. This component allows you to specify what modules the application will use; it then locates each module and initializes it. Module classes can tie into various listeners in order to provide configuration, services, listeners, and more to the application. Sounds complicated? It's not. Configuring the Module Manager The first step is configuring the module manager. Inform the module manager which modules to load, and potentially provide configuration for the module listeners. Remember the application.config.php from earlier? We're going to provide some configuration. // config/application.config.php return [ 'modules' =&gt; [ /* ... */ ], 'module_listener_options' =&gt; [ 'module_paths' =&gt; [ './module', './vendor', ], ], ]; As we add modules to the system, we'll add items to the modules array. Each Module class that has configuration it wants the Application to know about should define a getConfig() method. That method should return an array or Traversable object such as a Laminas\\Config\\Config instance. As an example: namespace LaminasUser; class Module { public function getConfig() : array { return include __DIR__ . '/config/module.config.php' } } There are a number of other methods you can define for tasks ranging from providing autoloader configuration, to providing services to the ServiceManager , to listening to the bootstrap event. The ModuleManager documentation goes into more detail on these. Conclusion laminas-mvc is incredibly flexible, offering an opt-in, easy to create modular infrastructure, as well as the ability to craft your own application workflows via the ServiceManager and EventManager . The ModuleManager is a lightweight and simple approach to enforcing a modular architecture that encourages clean separation of concerns and code re-use.","title":"Introduction"},{"location":"intro/#introduction","text":"laminas-mvc is the MVC layer shipped with Laminas and above, and focuses on performance and flexibility. The MVC layer is built on top of the following components: laminas-servicemanager - laminas-mvc provides a set of default service definitions, used to create and configure the application instance and workflow. laminas-eventmanager - The MVC is event driven, and uses events for the initial bootstrapping of the application, for returning response and request calls, for matching routes, and even for rendering views. laminas-http - specifically the request and response objects from the Laminas\\Http\\PhpEnvironment namespace, which provide objects that ensure the request is injected with the current environment (including query parameters, POST parameters, HTTP headers, etc.), and that the response will interact correctly with the SAPI and output buffering. laminas-stdlib - specifically Laminas\\Stdlib\\DispatchableInterface . All \"controllers\" are simply dispatchable objects. laminas-router - provides routing of a request. In other words, it matches the request to its respective controller (or dispatchable). Within the MVC layer, several sub-components are exposed: Laminas\\Mvc\\Controller , a set of abstract \"controller\" classes with basic responsibilities such as event wiring, action dispatching, etc., as well as controller plugins. Laminas\\Mvc\\Service provides a set of laminas-servicemanager factories and definitions for the default application workflow. Laminas\\Mvc\\View provides default wiring for renderer selection, view script resolution, helper registration, and more; additionally, it provides a number of listeners that tie into the MVC workflow, providing features such as automated template name resolution, automated view model creation and injection, etc. The gateway to the MVC is the Laminas\\Mvc\\Application object (referred to as Application henceforth). Its primary responsibilities are to bootstrap resources, to route the request, and to retrieve and dispatch the controller matched during routing. Once accomplished, it will render the view, and finish the request, returning and sending the response.","title":"Introduction"},{"location":"intro/#basic-application-structure","text":"The basic application structure follows: application_root/ config/ application.config.php autoload/ global.php local.php // etc. data/ module/ vendor/ public/ .htaccess index.php The public/index.php script marshals all user requests to your website, retrieving an array of configuration from config/application.config.php . On return, it run() s the Application , processing the request and returning a response to the user. The config directory as described above contains configuration used by laminas-modulemanager to load modules and merge configuration (e.g., database configuration and credentials); we will detail this more later. The vendor sub-directory should contain any third-party modules or libraries on which your application depends. This might include Laminas, custom libraries from your organization, or other third-party libraries from other projects. Libraries and modules placed in the vendor sub-directory should not be modified from their original, distributed state. Typically, this directory will be managed by Composer . Finally, the module directory will contain one or more modules delivering your application's functionality. Let's now turn to modules, as they are the basic units of a web application.","title":"Basic Application Structure"},{"location":"intro/#basic-module-structure","text":"A module may contain anything: PHP code, including MVC functionality; library code; view scripts; and/or or public assets such as images, CSS, and JavaScript. The only requirement — and even this is optional — is that a module acts as a PHP namespace and that it contains a Module class under that namespace. This class is eventually consumed by laminas-modulemanager to perform a number of tasks. The recommended module structure follows: module_root&lt;named-after-module-namespace&gt;/ Module.php autoload_classmap.php autoload_function.php autoload_register.php config/ module.config.php public/ images/ css/ js/ src/ &lt;module_namespace&gt;/ &lt;code files&gt; test/ phpunit.xml bootstrap.php &lt;module_namespace&gt;/ &lt;test code files&gt; view/ &lt;dir-named-after-module-namespace&gt;/ &lt;dir-named-after-a-controller&gt;/ &lt;.phtml files&gt; Since a module acts as a namespace, the module root directory should be that namespace. This namespace could also include a vendor prefix of sorts. As an example a module centered around \"User\" functionality delivered by Laminas might be named \"LaminasUser\", and this is also what the module root directory will be named.","title":"Basic Module Structure"},{"location":"intro/#bootstrapping-an-application","text":"The Application has seven basic dependencies. configuration , usually an array or object implementing Traversable . ServiceManager instance. EventManager instance, which, by default, is pulled from the ServiceManager , by the service name \"EventManager\". SharedEventManager instance, which, by default, is pulled from the ServiceManager , by the service name \"SharedEventManager\"; this is injected into the EventManager instance, and then pushed into every new EventManager instance created. ModuleManager instance, which, by default, is pulled from the ServiceManager , by the service name \"ModuleManager\". Request instance, which, by default, is pulled from the ServiceManager , by the service name \"Request\". Response instance, which, by default, is pulled from the ServiceManager , by the service name \"Response\". These may be satisfied at instantiation: use Laminas\\EventManager\\EventManager; use Laminas\\EventManager\\SharedEventManager; use Laminas\\Http\\PhpEnvironment; use Laminas\\ModuleManager\\ModuleManager; use Laminas\\Mvc\\Application; use Laminas\\ServiceManager\\ServiceManager; $config = include 'config/application.config.php'; $serviceManager = new ServiceManager(); $serviceManager-&gt;setService('SharedEventManager', new SharedEventManager()); $serviceManager-&gt;setService('ModuleManager', new ModuleManager($config)); $serviceManager-&gt;setService('Request', new PhpEnvironment\\Request()); $serviceManager-&gt;setService('Response', new PhpEnvironment\\Response()); $serviceManager-&gt;setFactory('EventManager', function ($serviceManager) { return new EventManager($serviceManager-&gt;get('SharedEventManager')); }); $serviceManager-&gt;setShared('EventManager', false); $application = new Application($config, $serviceManager); Once you've done this, there are two additional actions you can take. The first is to \"bootstrap\" the application. In the default implementation, this does the following: Attaches the default route listener ( Laminas\\Mvc\\RouteListener ). Attaches the middleware dispatch listener ( Laminas\\Mvc\\MiddlewareListener ) (v2.7.0 and up). Attaches the default dispatch listener ( Laminas\\Mvc\\DispatchListener ). Attaches the ViewManager listener ( Laminas\\Mvc\\View\\ViewManager ). Creates the MvcEvent , and injects it with the application, request, and response; it also retrieves the router ( Laminas\\Router\\Http\\TreeRouteStack ) at this time and attaches it to the event. Triggers the \"bootstrap\" event. If you do not want these actions, or want to provide alternatives, you can do so by extending the Application class and/or manually coding what actions you want to occur. The second action you can take with the configured Application is to run() it. Calling this method performs the following: it triggers the \"route\" event, followed by the \"dispatch\" event, and, depending on execution, the \"render\" event When done, it triggers the \"finish\" event, and then returns the response instance. If an error occurs during either the \"route\" or \"dispatch\" event, a \"dispatch.error\" event is triggered as well. This is a lot to remember in order to bootstrap the application; in fact, we haven't covered all the services available by default yet. You can greatly simplify things by using the default ServiceManager configuration shipped with the MVC. use Laminas\\Loader\\AutoloaderFactory; use Laminas\\Mvc\\Service\\ServiceManagerConfig; use Laminas\\ServiceManager\\ServiceManager; // setup autoloader AutoloaderFactory::factory(); // get application stack configuration $configuration = include 'config/application.config.php'; // setup service manager $serviceManager = new ServiceManager(new ServiceManagerConfig()); $serviceManager-&gt;setService('ApplicationConfig', $configuration); // load modules -- which will provide services, configuration, and more $serviceManager-&gt;get('ModuleManager')-&gt;loadModules(); // bootstrap and run application $application = $serviceManager-&gt;get('Application'); $application-&gt;bootstrap(); $application-&gt;run(); You can make this even simpler by using the init() method of the Application . This is a static method for quick and easy initialization of the Application instance. use Laminas\\Loader\\AutoloaderFactory; use Laminas\\Mvc\\Application; use Laminas\\Mvc\\Service\\ServiceManagerConfig; use Laminas\\ServiceManager\\ServiceManager; // setup autoloader AutoloaderFactory::factory(); // get application stack configuration $configuration = include 'config/application.config.php'; // The init() method does something very similar with the previous example. Application::init($configuration)-&gt;run(); The init() does the following: Grabs the application configuration and pulls from the service_manager key, creating a ServiceManager instance with it and with the default services shipped with laminas-mvc; Creates a service named ApplicationConfig with the application configuration array; Grabs the ModuleManager service and loads the modules; bootstrap() s the Application and returns its instance.","title":"Bootstrapping an Application"},{"location":"intro/#bootstrapping-a-modular-application","text":"While the previous approach largely works, where does the configuration come from? When we create a modular application, the assumption will be that it's from the modules themselves. How do we get that information and aggregate it, then? The answer is via laminas-modulemanager. This component allows you to specify what modules the application will use; it then locates each module and initializes it. Module classes can tie into various listeners in order to provide configuration, services, listeners, and more to the application. Sounds complicated? It's not.","title":"Bootstrapping a Modular Application"},{"location":"intro/#conclusion","text":"laminas-mvc is incredibly flexible, offering an opt-in, easy to create modular infrastructure, as well as the ability to craft your own application workflows via the ServiceManager and EventManager . The ModuleManager is a lightweight and simple approach to enforcing a modular architecture that encourages clean separation of concerns and code re-use.","title":"Conclusion"},{"location":"middleware/","text":"Dispatching PSR-7 Middleware PSR-7 defines interfaces for HTTP messages, and is now being adopted by many frameworks; Laminas itself offers a parallel microframework targeting PSR-7 with Mezzio . What if you want to dispatch PSR-7 middleware from laminas-mvc? laminas-mvc currently uses laminas-http for its HTTP transport layer, and the objects it defines are not compatible with PSR-7, meaning the basic MVC layer does not and cannot make use of PSR-7 currently. The package laminas-mvc-middleware is a laminas-mvc application module that enables dispatching of middleware, middleware pipes, and request handlers for route matches that contain a middleware parameter. Built-in Optional Support Deprecation With version 2.7.0, laminas-mvc began offering the now deprecated Laminas\\Mvc\\MiddlewareListener . The MiddlewareListener is always enabled, but requires optional dependencies installed to be used. A new laminas-mvc module, laminas-mvc-middleware , transparently replaces it with Laminas\\Mvc\\Middleware\\MiddlewareListener when registered with a laminas-mvc application. Starting with version 3.2.0, the built-in Laminas\\Mvc\\MiddlewareListener will trigger deprecation level errors on any attempt to handle a route match containing a middleware parameter. If your application currently depends on the built-in optional middleware support, laminas/laminas-mvc-middleware:~1.0.0 provides a drop-in replacement. If you use this new module, please note that the module Laminas\\Mvc\\Middleware must be enabled in your laminas-mvc application.","title":"Dispatching PSR-7 Middleware"},{"location":"middleware/#dispatching-psr-7-middleware","text":"PSR-7 defines interfaces for HTTP messages, and is now being adopted by many frameworks; Laminas itself offers a parallel microframework targeting PSR-7 with Mezzio . What if you want to dispatch PSR-7 middleware from laminas-mvc? laminas-mvc currently uses laminas-http for its HTTP transport layer, and the objects it defines are not compatible with PSR-7, meaning the basic MVC layer does not and cannot make use of PSR-7 currently. The package laminas-mvc-middleware is a laminas-mvc application module that enables dispatching of middleware, middleware pipes, and request handlers for route matches that contain a middleware parameter.","title":"Dispatching PSR-7 Middleware"},{"location":"middleware/#built-in-optional-support-deprecation","text":"With version 2.7.0, laminas-mvc began offering the now deprecated Laminas\\Mvc\\MiddlewareListener . The MiddlewareListener is always enabled, but requires optional dependencies installed to be used. A new laminas-mvc module, laminas-mvc-middleware , transparently replaces it with Laminas\\Mvc\\Middleware\\MiddlewareListener when registered with a laminas-mvc application. Starting with version 3.2.0, the built-in Laminas\\Mvc\\MiddlewareListener will trigger deprecation level errors on any attempt to handle a route match containing a middleware parameter. If your application currently depends on the built-in optional middleware support, laminas/laminas-mvc-middleware:~1.0.0 provides a drop-in replacement. If you use this new module, please note that the module Laminas\\Mvc\\Middleware must be enabled in your laminas-mvc application.","title":"Built-in Optional Support Deprecation"},{"location":"modules/","text":"Modules A module is a PHP namespace. It can contain controllers, classes, view scripts, configuration, tests, as well as public assets such as images, CSS, and JavaScript. For example, if you have an e-commerce application, you could have a module for presenting and selling products, and another for administrators to create products and manage orders. File and Directory Structure Given a module named Application , here is the recommended structure: Application/ config/ module.config.php public/ images/ css/ js/ src/ Controller/ ProductController.php Module.php &lt;other classes&gt; test/ Controller/ ProductControllerTest.php view/ application/ product/ list.phtml layout/ layout.phtml Loading All module classes can be autoloaded by Composer by adding them as a namespace in composer.json : \"autoload\": { \"psr-4\": { \"Application\\\\\": \"module/Application/src/\" } } This means that whenever you refer to a class in the Application namespace, PHP will look for it in the module/Application/src/ folder. A class named Application\\Controller\\ProductController would be found in the file module/Application/src/Controller/ProductController.php . In addition to autoloading, the application needs to be aware that the Application namespace represents a module. This is accomplished by adding it to the module configuration of the application in config/modules.config.php : return [ 'Application', // other modules ]; Listeners Each module has a Module class, which can contain a variety of methods called listeners. These listeners are called by laminas-modulemanager to configure the module. For the namespace Application , the module manager will look for Application\\Module . Here is a simple example that loads a module-specific configuration file: namespace Application; class Module { public function getConfig(): array { /** @var array $config */ $config = include __DIR__ . '/../config/module.config.php'; return $config; } } getModuleDependencies() Checks each module to verify whether all the modules it depends on were loaded. Each of the values returned by the method is checked against the loaded modules list: if one of the values is not in that list, a Laminas\\ModuleManager\\Exception\\MissingDependencyModuleException is thrown. namespace Application; use Laminas\\ModuleManager\\Feature\\DependencyIndicatorInterface; class Module implements DependencyIndicatorInterface { public function getDependencies(): array { return [ 'Product' ]; } } // Add other methods following the same structure as getModuleDependencies() Be sure to read about Best Practices when Creating Modules .","title":"Modules"},{"location":"modules/#modules","text":"A module is a PHP namespace. It can contain controllers, classes, view scripts, configuration, tests, as well as public assets such as images, CSS, and JavaScript. For example, if you have an e-commerce application, you could have a module for presenting and selling products, and another for administrators to create products and manage orders.","title":"Modules"},{"location":"modules/#file-and-directory-structure","text":"Given a module named Application , here is the recommended structure: Application/ config/ module.config.php public/ images/ css/ js/ src/ Controller/ ProductController.php Module.php &lt;other classes&gt; test/ Controller/ ProductControllerTest.php view/ application/ product/ list.phtml layout/ layout.phtml","title":"File and Directory Structure"},{"location":"modules/#loading","text":"All module classes can be autoloaded by Composer by adding them as a namespace in composer.json : \"autoload\": { \"psr-4\": { \"Application\\\\\": \"module/Application/src/\" } } This means that whenever you refer to a class in the Application namespace, PHP will look for it in the module/Application/src/ folder. A class named Application\\Controller\\ProductController would be found in the file module/Application/src/Controller/ProductController.php . In addition to autoloading, the application needs to be aware that the Application namespace represents a module. This is accomplished by adding it to the module configuration of the application in config/modules.config.php : return [ 'Application', // other modules ];","title":"Loading"},{"location":"modules/#listeners","text":"Each module has a Module class, which can contain a variety of methods called listeners. These listeners are called by laminas-modulemanager to configure the module. For the namespace Application , the module manager will look for Application\\Module . Here is a simple example that loads a module-specific configuration file: namespace Application; class Module { public function getConfig(): array { /** @var array $config */ $config = include __DIR__ . '/../config/module.config.php'; return $config; } }","title":"Listeners"},{"location":"mvc-event/","text":"The MvcEvent laminas-mvc defines and utilizes a custom Laminas\\EventManager\\Event implementation, Laminas\\Mvc\\MvcEvent . This event is created during Laminas\\Mvc\\Application::bootstrap() and is passed when triggering all application events. Additionally, if your controllers implement the Laminas\\Mvc\\InjectApplicationEventInterface , MvcEvent will be injected into those controllers. The MvcEvent adds accessors and mutators for the following: Application object. Request object. Response object. Router object. RouteMatch object. Result - usually the result of dispatching a controller. ViewModel object, typically representing the layout view model. The methods it defines are: setApplication($application) getApplication() setRequest($request) getRequest() setResponse($response) getResponse() setRouter($router) getRouter() setRouteMatch($routeMatch) getRouteMatch() setResult($result) getResult() setViewModel($viewModel) getViewModel() isError() setError() getError() getController() setController($name) getControllerClass() setControllerClass($class) The Application , Request , Response , Router , and ViewModel are all injected during the bootstrap event. Following the route event, it will be injected also with the RouteMatch object encapsulating the results of routing. Since this object is passed around throughout the MVC, it is a common location for retrieving the results of routing, the router, and the request and response objects. Additionally, we encourage setting the results of execution in the event, to allow event listeners to introspect them and utilize them within their execution. As an example, the results could be passed into a view renderer. Order of events The following events are triggered, in the following order: Name Constant Description bootstrap MvcEvent::EVENT_BOOTSTRAP Bootstrap the application by creating the ViewManager. route MvcEvent::EVENT_ROUTE Perform routing (or route-related actions). dispatch MvcEvent::EVENT_DISPATCH Dispatch the matched route to a controller/action. dispatch.error MvcEvent::EVENT_DISPATCH_ERROR Event triggered in case of a problem during dispatch process (e.g., unknown controller). render MvcEvent::EVENT_RENDER Prepare the data and delegate the rendering to the view layer. render.error MvcEvent::EVENT_RENDER_ERROR Event triggered in case of a problem during the render process (e.g., no renderer found). finish MvcEvent::EVENT_FINISH Perform tasks once everything else is done. The following sections provide more detail on each event. MvcEvent::EVENT_BOOTSTRAP (\"bootstrap\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Triggers Description Laminas\\Mvc\\View\\Http\\ViewManager 10000 onBootstrap none Prepares the view layer (instantiate a Laminas\\Mvc\\View\\Http\\ViewManager ). Triggered By This event is triggered by the following classes: Class In Method Laminas\\Mvc\\Application bootstrap MvcEvent::EVENT_ROUTE (\"route\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Triggers Description Laminas\\Mvc\\ModuleRouteListener 1 onRoute none Determines if the module namespace should be prepended to the controller name. This is the case if the route match contains a parameter key matching the MODULE_NAMESPACE constant. Laminas\\Mvc\\RouteListener 1 onRoute MvcEvent::EVENT_DISPATCH_ERROR (if no route is matched) Tries to match the request to the router and return a RouteMatch object. Triggered By This event is triggered by the following classes: Class In Method Description Laminas\\Mvc\\Application run Uses a short circuit callback that allows halting propagation of the event if an error is raised during routing. MvcEvent::EVENT_DISPATCH (\"dispatch\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Console context only The following listeners are only attached in a console context: Class Priority Method Called Description Laminas\\Mvc\\View\\Console\\InjectNamedConsoleParamsListener 1000 injectNamedParams Merge all params (route match params and params in the command), and add them to the Request object. Laminas\\Mvc\\View\\Console\\CreateViewModelListener -80 createViewModelFromArray If the controller action returns an associative array, this listener casts it to a ConsoleModel object. Laminas\\Mvc\\View\\Console\\CreateViewModelListener -80 createViewModelFromString If the controller action returns a string, this listener casts it to a ConsoleModel object. Laminas\\Mvc\\View\\Console\\CreateViewModelListener -80 createViewModelFromNull If the controller action returns null, this listener casts it to a ConsoleModel object. Laminas\\Mvc\\View\\Console\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ConsoleModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminal. HTTP context only The following listeners are only attached in an HTTP context: Class Priority Method Called Description Laminas\\Mvc\\View\\Http\\CreateViewModelListener -80 createViewModelFromArray If the controller action returns an associative array, this listener casts it to a ViewModel object. Laminas\\Mvc\\View\\Http\\CreateViewModelListener -80 createViewModelFromNull If the controller action returns null, this listener casts it to a ViewModel object. Laminas\\Mvc\\View\\Http\\RouteNotFoundStrategy -90 prepareNotFoundViewModel Creates and return a 404 ViewModel . Laminas\\Mvc\\View\\Http\\InjectTemplateListener -90 injectTemplate Injects a template into the view model, if none present. Template name is derived from the controller found in the route match, and, optionally, the action, if present. Laminas\\Mvc\\View\\Http\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. All contexts The following listeners are attached for all contexts (sorted from higher priority to lower priority): Class Priority Method Called Triggers Description Laminas\\Mvc\\MiddlewareListener 1 onDispatch MvcEvent::EVENT_DISPATCH_ERROR (if an exception is raised during dispatch processes) Load and dispatch the matched PSR-7 middleware from the service manager (and throws various exceptions if it does not). Laminas\\Mvc\\DispatchListener 1 onDispatch MvcEvent::EVENT_DISPATCH_ERROR (if an exception is raised during dispatch processes) Load and dispatch the matched controller from the service manager (and throws various exceptions if it does not). Laminas\\Mvc\\AbstractController 1 onDispatch none The onDispatch method of the AbstractController is an abstract method. In AbstractActionController , for instance, it calls the action method. Triggered By This event is triggered by the following classes: Class In Method Description Laminas\\Mvc\\Application run Uses a short circuit callback to halt propagation of the event if an error is raised during routing. Laminas\\Mvc\\Controller\\AbstractController dispatch If a listener returns a Response object, it halts propagation. Note: every AbstractController listens to this event and executes the onDispatch method when it is triggered. MvcEvent::EVENT_DISPATCH_ERROR (\"dispatch.error\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Console context only The following listeners are only attached in a console context: Class Priority Method Called Description Laminas\\Mvc\\View\\Console\\RouteNotFoundStrategy 1 handleRouteNotFoundError Detect if an error is a \"route not found\" condition. If a “controller not found” or “invalid controller” error type is encountered, sets the response status code to 404. Laminas\\Mvc\\View\\Console\\ExceptionStrategy 1 prepareExceptionViewModel Create an exception view model, and sets the status code to 404. Laminas\\Mvc\\View\\Console\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ConsoleModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. HTTP context only The following listeners are only attached in an HTTP context: Class Priority Method Called Description Laminas\\Mvc\\View\\Http\\RouteNotFoundStrategy 1 detectNotFoundError Detect if an error is a 404 condition. If a “controller not found” or “invalid controller” error type is encountered, sets the response status code to 404. Laminas\\Mvc\\View\\Http\\RouteNotFoundStrategy 1 prepareNotFoundViewModel Create and return a 404 view model. Laminas\\Mvc\\View\\Http\\ExceptionStrategy 1 prepareExceptionViewModel Create an exception view model and set the status code to 404. Laminas\\Mvc\\View\\Http\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. All contexts The following listeners are attached for all contexts: Class Priority Method Called Description Laminas\\Mvc\\DispatchListener 1 reportMonitorEvent Used for monitoring when Zend Server is used. Triggered By Class In Method Laminas\\Mvc\\MiddlewareListener onDispatch Laminas\\Mvc\\DispatchListener onDispatch Laminas\\Mvc\\DispatchListener marshallControllerNotFoundEvent Laminas\\Mvc\\DispatchListener marshallBadControllerEvent MvcEvent::EVENT_RENDER (\"render\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Console context only The following listeners are only attached in a console context: Class Priority Method Called Description Laminas\\Mvc\\View\\Console\\DefaultRenderingStrategy -10000 render Render the view. HTTP context only The following listeners are only attached in an HTTP context: Class Priority Method Called Description Laminas\\Mvc\\View\\Http\\DefaultRenderingStrategy -10000 render Render the view. Triggered By This event is triggered by the following classes: Class In Method Description Laminas\\Mvc\\Application completeRequest This event is triggered just before the MvcEvent::FINISH event. MvcEvent::EVENT_RENDER_ERROR (\"render.error\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Console context only The following listeners are only attached in a console context: Class Priority Method Called Description Laminas\\Mvc\\View\\Console\\ExceptionStrategy 1 prepareExceptionViewModel Create an exception view model and set the status code to 404. Laminas\\Mvc\\View\\Console\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ConsoleModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. HTTP context only The following listeners are only attached in an HTTP context: Class Priority Method Called Description Laminas\\Mvc\\View\\Http\\ExceptionStrategy 1 prepareExceptionViewModel Create an exception view model and set the status code to 404. Laminas\\Mvc\\View\\Http\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. Laminas\\Mvc\\View\\Http\\DefaultRenderingStrategy -10000 render Render the view Triggered By This event is triggered by the following classes: Class In Method Description Laminas\\Mvc\\View\\Http\\DefaultRenderingStrategy render This event is triggered if an exception is raised during rendering. MvcEvent::EVENT_FINISH (\"finish\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Description Laminas\\Mvc\\SendResponseListener -10000 sendResponse Triggers the SendResponseEvent in order to prepare the response (see the next chapter for more information about SendResponseEvent ). Triggered By This event is triggered by the following classes: Class In Method Description Laminas\\Mvc\\Application run This event is triggered once the MvcEvent::ROUTE event returns a correct ResponseInterface . Laminas\\Mvc\\Application run This event is triggered once the MvcEvent::DISPATCH event returns a correct ResponseInterface . Laminas\\Mvc\\Application completeRequest This event is triggered after MvcEvent::RENDER (at this point, the view is already rendered).","title":"The MVC Event"},{"location":"mvc-event/#the-mvcevent","text":"laminas-mvc defines and utilizes a custom Laminas\\EventManager\\Event implementation, Laminas\\Mvc\\MvcEvent . This event is created during Laminas\\Mvc\\Application::bootstrap() and is passed when triggering all application events. Additionally, if your controllers implement the Laminas\\Mvc\\InjectApplicationEventInterface , MvcEvent will be injected into those controllers. The MvcEvent adds accessors and mutators for the following: Application object. Request object. Response object. Router object. RouteMatch object. Result - usually the result of dispatching a controller. ViewModel object, typically representing the layout view model. The methods it defines are: setApplication($application) getApplication() setRequest($request) getRequest() setResponse($response) getResponse() setRouter($router) getRouter() setRouteMatch($routeMatch) getRouteMatch() setResult($result) getResult() setViewModel($viewModel) getViewModel() isError() setError() getError() getController() setController($name) getControllerClass() setControllerClass($class) The Application , Request , Response , Router , and ViewModel are all injected during the bootstrap event. Following the route event, it will be injected also with the RouteMatch object encapsulating the results of routing. Since this object is passed around throughout the MVC, it is a common location for retrieving the results of routing, the router, and the request and response objects. Additionally, we encourage setting the results of execution in the event, to allow event listeners to introspect them and utilize them within their execution. As an example, the results could be passed into a view renderer.","title":"The MvcEvent"},{"location":"mvc-event/#order-of-events","text":"The following events are triggered, in the following order: Name Constant Description bootstrap MvcEvent::EVENT_BOOTSTRAP Bootstrap the application by creating the ViewManager. route MvcEvent::EVENT_ROUTE Perform routing (or route-related actions). dispatch MvcEvent::EVENT_DISPATCH Dispatch the matched route to a controller/action. dispatch.error MvcEvent::EVENT_DISPATCH_ERROR Event triggered in case of a problem during dispatch process (e.g., unknown controller). render MvcEvent::EVENT_RENDER Prepare the data and delegate the rendering to the view layer. render.error MvcEvent::EVENT_RENDER_ERROR Event triggered in case of a problem during the render process (e.g., no renderer found). finish MvcEvent::EVENT_FINISH Perform tasks once everything else is done. The following sections provide more detail on each event.","title":"Order of events"},{"location":"mvc-event/#mvceventevent_bootstrap-bootstrap","text":"","title":"MvcEvent::EVENT_BOOTSTRAP (\"bootstrap\")"},{"location":"mvc-event/#mvceventevent_route-route","text":"","title":"MvcEvent::EVENT_ROUTE (\"route\")"},{"location":"mvc-event/#mvceventevent_dispatch-dispatch","text":"","title":"MvcEvent::EVENT_DISPATCH (\"dispatch\")"},{"location":"mvc-event/#mvceventevent_dispatch_error-dispatcherror","text":"","title":"MvcEvent::EVENT_DISPATCH_ERROR (\"dispatch.error\")"},{"location":"mvc-event/#mvceventevent_render-render","text":"","title":"MvcEvent::EVENT_RENDER (\"render\")"},{"location":"mvc-event/#mvceventevent_render_error-rendererror","text":"","title":"MvcEvent::EVENT_RENDER_ERROR (\"render.error\")"},{"location":"mvc-event/#mvceventevent_finish-finish","text":"","title":"MvcEvent::EVENT_FINISH (\"finish\")"},{"location":"plugins/","text":"Controller Plugins When using any of the abstract controller implementations shipped with laminas-mvc, or if you implement the setPluginManager method in your custom controllers, you have access to a number of pre-built plugins. Additionally, you can register your own custom plugins with the manager. The built-in plugins are: Laminas\\Mvc\\Controller\\Plugin\\AcceptableViewModelSelector Laminas\\Mvc\\Controller\\Plugin\\Forward Laminas\\Mvc\\Controller\\Plugin\\Layout Laminas\\Mvc\\Controller\\Plugin\\Params Laminas\\Mvc\\Controller\\Plugin\\Redirect Laminas\\Mvc\\Controller\\Plugin\\Url If your controller implements the setPluginManager() , getPluginManager() and plugin() methods, you can access these using their shortname via the plugin() method: $plugin = $this-&gt;plugin('url'); For an extra layer of convenience, this shipped abstract controller implementations have __call() methods defined that allow you to retrieve plugins via method calls: $plugin = $this-&gt;url(); AcceptableViewModelSelector Plugin The AcceptableViewModelSelector is a helper that can be used to select an appropriate view model based on user defined criteria will be tested against the Accept header in the request. As an example: use Laminas\\Mvc\\Controller\\AbstractActionController; class SomeController extends AbstractActionController { protected $acceptCriteria = [ \\Laminas\\View\\Model\\ViewModel::class =&gt; [ 'text/html', 'application/xhtml+xml', ], \\Laminas\\View\\Model\\JsonModel::class =&gt; [ 'application/json', 'application/javascript', ], \\Laminas\\View\\Model\\FeedModel::class =&gt; [ 'application/rss+xml', 'application/atom+xml', ], ]; public function apiAction() { $viewModel = $this-&gt;acceptableViewModelSelector($this-&gt;acceptCriteria); // Potentially vary execution based on model returned if ($viewModel instanceof \\Laminas\\View\\Model\\JsonModel) { // ... } } } The above would return a standard Laminas\\View\\Model\\ViewModel instance if no criteria are met, and the specified view model types if a specific criterion is met. Rules are matched in order, with the first match \"winning\". Make sure to put your fallback view model first as a fallback for unknown content types or */* . Browsers are sending */* as last content type of the Accept header, so you have to define every acceptable view model and their content type. Forward Plugin Occasionally, you may want to dispatch additional controllers from within the matched controller. For example, you might use this approach to build up \"widgetized\" content. The Forward plugin helps enable this. For the Forward plugin to work, the controller calling it must be ServiceLocatorAware ; otherwise, the plugin will be unable to retrieve a configured and injected instance of the requested controller. The plugin exposes a single method, dispatch() , which takes two arguments: $name , the name of the controller to invoke. This may be either the fully qualified class name, or an alias defined and recognized by the ServiceManager instance attached to the invoking controller. $params is an optional array of parameters with which to seed a RouteMatch object for purposes of this specific request. Meaning the parameters will be matched by their key to the routing identifiers in the config (otherwise non-matching keys are ignored) Forward returns the results of dispatching the requested controller; it is up to the developer to determine what, if anything, to do with those results. One recommendation is to aggregate them in any return value from the invoking controller. As an example: $foo = $this-&gt;forward()-&gt;dispatch('foo', ['action' =&gt; 'process']); return [ 'somekey' =&gt; $somevalue, 'foo' =&gt; $foo, ]; Layout Plugin The Layout plugin allows changing layout templates from within controller actions. It exposes a single method, setTemplate() , which takes one argument, $template , the name of the template to set. As an example: $this-&gt;layout()-&gt;setTemplate('layout/newlayout'); It also implements the __invoke magic method, which allows calling the plugin as a method call: $this-&gt;layout('layout/newlayout'); Params Plugin The Params plugin allows accessing parameters in actions from different sources. It exposes several methods, one for each parameter source: fromFiles(string $name = null, mixed $default = null): array|ArrayAccess|null : For retrieving all or one single file . If $name is null, all files will be returned. fromHeader(string $header = null, mixed $default = null) : null|Laminas\\Http\\Header\\HeaderInterface : For retrieving all or one single header parameter. If $header is null, all header parameters will be returned. fromPost(string $param = null, mixed $default = null) : mixed : For retrieving all or one single post parameter. If $param is null, all post parameters will be returned. fromQuery(string $param = null, mixed $default = null) : mixed : For retrieving all or one single query parameter. If $param is null, all query parameters will be returned. fromRoute(string $param = null, mixed $default = null) : mixed : For retrieving all or one single route parameter. If $param is null, all route parameters will be returned. The plugin also implements the __invoke magic method, providing a shortcut for invoking the fromRoute method: $this-&gt;params()-&gt;fromRoute('param', $default); // or $this-&gt;params('param', $default); Redirect Plugin Redirections are quite common operations within applications. If done manually, you will need to do the following steps: Assemble a url using the router. Create and inject a \"Location\" header into the Response object, pointing to the assembled URL. Set the status code of the Response object to one of the 3xx HTTP statuses. The Redirect plugin does this work for you. It offers three methods: toRoute(string $route = null, array $params = [], array $options = [], bool $reuseMatchedParams = false) : Laminas\\Http\\Response : Redirects to a named route, using the provided $params and $options to assembled the URL. toUrl(string $url) : Laminas\\Http\\Response : Simply redirects to the given URL. refresh() : Laminas\\Http\\Response : Refresh to current route. In each case, the Response object is returned. If you return this immediately, you can effectively short-circuit execution of the request. By default, the returned Response object has the HTTP status set to 302 . To set a different status use the Laminas\\Http\\Respons::setStatusCode method. Requires MvcEvent This plugin requires that the controller invoking it implements InjectApplicationEventInterface , and thus has an MvcEvent composed, as it retrieves the router from the event object. As an example: return $this-&gt;redirect()-&gt;toRoute('login-success'); // with status code using fluent interface return $this-&gt;redirect() -&gt;toRoute('new-landing-page') -&gt;setStatusCode(\\Laminas\\Http\\Response::STATUS_CODE_301); Url Plugin You may need to generate URLs from route definitions within your controllers; for example, to seed the view, generate headers, etc. While the MvcEvent object composes the router, doing so manually would require this workflow: $router = $this-&gt;getEvent()-&gt;getRouter(); $url = $router-&gt;assemble($params, ['name' =&gt; 'route-name']); The Url helper makes this slightly more convenient: $url = $this-&gt;url()-&gt;fromRoute('route-name', $params); The fromRoute() method is the only public method defined, and is used to generate a URL string from the provided parameters. It has the following signature: fromRoute(string $route = null, array $params = [], array $options = [], bool $reuseMatchedParams = false): string , where: $name : the name of the route to use for URL generation. $params : Any parameter substitutions to use with the named route. $options : Options used by the router when generating the URL (e.g., force_canonical , query , etc.). $reuseMatchedParams : Whether or not to use route match parameters from the current URL when generating the new URL. This will only affect cases where the specified $name matches the currently matched route; the default is true . Requires MvcEvent This plugin requires that the controller invoking it implements InjectApplicationEventInterface , and thus has an MvcEvent composed, as it retrieves the router from the event object.","title":"Controller Plugins"},{"location":"plugins/#controller-plugins","text":"When using any of the abstract controller implementations shipped with laminas-mvc, or if you implement the setPluginManager method in your custom controllers, you have access to a number of pre-built plugins. Additionally, you can register your own custom plugins with the manager. The built-in plugins are: Laminas\\Mvc\\Controller\\Plugin\\AcceptableViewModelSelector Laminas\\Mvc\\Controller\\Plugin\\Forward Laminas\\Mvc\\Controller\\Plugin\\Layout Laminas\\Mvc\\Controller\\Plugin\\Params Laminas\\Mvc\\Controller\\Plugin\\Redirect Laminas\\Mvc\\Controller\\Plugin\\Url If your controller implements the setPluginManager() , getPluginManager() and plugin() methods, you can access these using their shortname via the plugin() method: $plugin = $this-&gt;plugin('url'); For an extra layer of convenience, this shipped abstract controller implementations have __call() methods defined that allow you to retrieve plugins via method calls: $plugin = $this-&gt;url();","title":"Controller Plugins"},{"location":"plugins/#acceptableviewmodelselector-plugin","text":"The AcceptableViewModelSelector is a helper that can be used to select an appropriate view model based on user defined criteria will be tested against the Accept header in the request. As an example: use Laminas\\Mvc\\Controller\\AbstractActionController; class SomeController extends AbstractActionController { protected $acceptCriteria = [ \\Laminas\\View\\Model\\ViewModel::class =&gt; [ 'text/html', 'application/xhtml+xml', ], \\Laminas\\View\\Model\\JsonModel::class =&gt; [ 'application/json', 'application/javascript', ], \\Laminas\\View\\Model\\FeedModel::class =&gt; [ 'application/rss+xml', 'application/atom+xml', ], ]; public function apiAction() { $viewModel = $this-&gt;acceptableViewModelSelector($this-&gt;acceptCriteria); // Potentially vary execution based on model returned if ($viewModel instanceof \\Laminas\\View\\Model\\JsonModel) { // ... } } } The above would return a standard Laminas\\View\\Model\\ViewModel instance if no criteria are met, and the specified view model types if a specific criterion is met. Rules are matched in order, with the first match \"winning\". Make sure to put your fallback view model first as a fallback for unknown content types or */* . Browsers are sending */* as last content type of the Accept header, so you have to define every acceptable view model and their content type.","title":"AcceptableViewModelSelector Plugin"},{"location":"plugins/#forward-plugin","text":"Occasionally, you may want to dispatch additional controllers from within the matched controller. For example, you might use this approach to build up \"widgetized\" content. The Forward plugin helps enable this. For the Forward plugin to work, the controller calling it must be ServiceLocatorAware ; otherwise, the plugin will be unable to retrieve a configured and injected instance of the requested controller. The plugin exposes a single method, dispatch() , which takes two arguments: $name , the name of the controller to invoke. This may be either the fully qualified class name, or an alias defined and recognized by the ServiceManager instance attached to the invoking controller. $params is an optional array of parameters with which to seed a RouteMatch object for purposes of this specific request. Meaning the parameters will be matched by their key to the routing identifiers in the config (otherwise non-matching keys are ignored) Forward returns the results of dispatching the requested controller; it is up to the developer to determine what, if anything, to do with those results. One recommendation is to aggregate them in any return value from the invoking controller. As an example: $foo = $this-&gt;forward()-&gt;dispatch('foo', ['action' =&gt; 'process']); return [ 'somekey' =&gt; $somevalue, 'foo' =&gt; $foo, ];","title":"Forward Plugin"},{"location":"plugins/#layout-plugin","text":"The Layout plugin allows changing layout templates from within controller actions. It exposes a single method, setTemplate() , which takes one argument, $template , the name of the template to set. As an example: $this-&gt;layout()-&gt;setTemplate('layout/newlayout'); It also implements the __invoke magic method, which allows calling the plugin as a method call: $this-&gt;layout('layout/newlayout');","title":"Layout Plugin"},{"location":"plugins/#params-plugin","text":"The Params plugin allows accessing parameters in actions from different sources. It exposes several methods, one for each parameter source: fromFiles(string $name = null, mixed $default = null): array|ArrayAccess|null : For retrieving all or one single file . If $name is null, all files will be returned. fromHeader(string $header = null, mixed $default = null) : null|Laminas\\Http\\Header\\HeaderInterface : For retrieving all or one single header parameter. If $header is null, all header parameters will be returned. fromPost(string $param = null, mixed $default = null) : mixed : For retrieving all or one single post parameter. If $param is null, all post parameters will be returned. fromQuery(string $param = null, mixed $default = null) : mixed : For retrieving all or one single query parameter. If $param is null, all query parameters will be returned. fromRoute(string $param = null, mixed $default = null) : mixed : For retrieving all or one single route parameter. If $param is null, all route parameters will be returned. The plugin also implements the __invoke magic method, providing a shortcut for invoking the fromRoute method: $this-&gt;params()-&gt;fromRoute('param', $default); // or $this-&gt;params('param', $default);","title":"Params Plugin"},{"location":"plugins/#redirect-plugin","text":"Redirections are quite common operations within applications. If done manually, you will need to do the following steps: Assemble a url using the router. Create and inject a \"Location\" header into the Response object, pointing to the assembled URL. Set the status code of the Response object to one of the 3xx HTTP statuses. The Redirect plugin does this work for you. It offers three methods: toRoute(string $route = null, array $params = [], array $options = [], bool $reuseMatchedParams = false) : Laminas\\Http\\Response : Redirects to a named route, using the provided $params and $options to assembled the URL. toUrl(string $url) : Laminas\\Http\\Response : Simply redirects to the given URL. refresh() : Laminas\\Http\\Response : Refresh to current route. In each case, the Response object is returned. If you return this immediately, you can effectively short-circuit execution of the request. By default, the returned Response object has the HTTP status set to 302 . To set a different status use the Laminas\\Http\\Respons::setStatusCode method.","title":"Redirect Plugin"},{"location":"plugins/#url-plugin","text":"You may need to generate URLs from route definitions within your controllers; for example, to seed the view, generate headers, etc. While the MvcEvent object composes the router, doing so manually would require this workflow: $router = $this-&gt;getEvent()-&gt;getRouter(); $url = $router-&gt;assemble($params, ['name' =&gt; 'route-name']); The Url helper makes this slightly more convenient: $url = $this-&gt;url()-&gt;fromRoute('route-name', $params); The fromRoute() method is the only public method defined, and is used to generate a URL string from the provided parameters. It has the following signature: fromRoute(string $route = null, array $params = [], array $options = [], bool $reuseMatchedParams = false): string , where: $name : the name of the route to use for URL generation. $params : Any parameter substitutions to use with the named route. $options : Options used by the router when generating the URL (e.g., force_canonical , query , etc.). $reuseMatchedParams : Whether or not to use route match parameters from the current URL when generating the new URL. This will only affect cases where the specified $name matches the currently matched route; the default is true .","title":"Url Plugin"},{"location":"quick-start/","text":"Quick Start In this example, /hello/world?message=welcome will display a page containing the message provided through the URL. This requires several steps: Create a controller to obtain the message from the URL, and pass it as a variable to the view Create a view to display a page containing the message Create a route to match the URL to the controller Throughout this example, we will work in the Application module of the skeleton. The relevant files are located under module/Application . Install the Laminas MVC Skeleton Application To get started, install the skeleton application via Composer. If you have not yet done so, install Composer . Once you have, use the create-project command to create a new application: $ composer create-project -s dev laminas/laminas-mvc-skeleton my-application Create a Controller Laminas MVC has several base controller classes for you to start with: AbstractActionController matches routes to methods within this class. For example, if you had a route with the \"list\" action, the \"listAction\" method will be called. AbstractRestfulController determines the HTTP method from the request, and calls a method according to that. For example, a POST HTTP method will call the update() method in the class. You can also create custom controllers by implementing Laminas\\Stdlib\\DispatchableInterface . Learn more about controllers in the chapter on controllers . We will use the AbstractActionController base controller. Create the file src/Application/Controller/HelloController.php . Add the following code: &lt;?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; // Create an action controller. class HelloController extends AbstractActionController { // Define an action \"world\". public function worldAction() { // Get \"message\" from the query parameters. // In production code, it's a good idea to sanitize user input. $message = $this-&gt;params()-&gt;fromQuery('message', 'hello'); // Pass variables to the view. return new ViewModel(['message' =&gt; $message]); } } By default, this controller will render the view script located in view/application/hello/world.phtml . You can customize this behavior. Learn more about views in the laminas-view documentation . Create a View Script Create the file view/application/hello/world.phtml and add the following code: &lt;h1&gt;Greetings!&lt;/h1&gt; &lt;p&gt;You said \"&lt;?php echo $this-&gt;escapeHtml($message) ?&gt;\".&lt;/p&gt; Escaping output The method escapeHtml() is a view helper , and it's designed to help mitigate XSS attacks. Never trust user input. If you are at all uncertain about the source of a variable in your view, escape it using one of the view helpers, depending on the type of data. Create a Route Routes determine which controller to call based on the URI and other information from the request. Configure a route and a controller in module/Application/config/module.config.php : return [ 'router' =&gt; [ 'routes' =&gt; [ // Route name: used to generate links, among other things. 'hello-world' =&gt; [ 'type' =&gt; Laminas\\Router\\Http\\Literal::class, // exact match of URI path 'options' =&gt; [ 'route' =&gt; '/hello/world', // URI path 'defaults' =&gt; [ 'controller' =&gt; Application\\Controller\\HelloController::class, // unique name 'action' =&gt; 'world', ], ], ], ], ], 'controllers' =&gt; [ // Tell the application how to instantiate our controller class 'factories' =&gt; [ Application\\Controller\\HelloController::class =&gt; Laminas\\ServiceManager\\Factory\\InvokableFactory::class, ], ], ]; When the URI path of the request matches /hello/world , the specified controller and action will be used. The controller name must be present under the controllers key in the configuration. The associated class will then be instantiated and invoked. Learn more about routing in the laminas-router documentation . Test it Out! Create a new vhost pointing its document root to the public directory of your application, and fire it up in a browser. You should see the default homepage template of laminas-mvc-skeleton . Append the path /hello/world to your URL and load the page. You should now get the following content: &lt;h1&gt;Greetings!&lt;/h1&gt; &lt;p&gt;You said \"hello\".&lt;/p&gt; Append ?message=welcome to your URL. You should now get: &lt;h1&gt;Greetings!&lt;/h1&gt; &lt;p&gt;You said \"welcome\".&lt;/p&gt; Congratulations! You've created your first Laminas MVC controller! Learn More Creating custom modules Controllers Views Routing","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"In this example, /hello/world?message=welcome will display a page containing the message provided through the URL. This requires several steps: Create a controller to obtain the message from the URL, and pass it as a variable to the view Create a view to display a page containing the message Create a route to match the URL to the controller Throughout this example, we will work in the Application module of the skeleton. The relevant files are located under module/Application .","title":"Quick Start"},{"location":"quick-start/#install-the-laminas-mvc-skeleton-application","text":"To get started, install the skeleton application via Composer. If you have not yet done so, install Composer . Once you have, use the create-project command to create a new application: $ composer create-project -s dev laminas/laminas-mvc-skeleton my-application","title":"Install the Laminas MVC Skeleton Application"},{"location":"quick-start/#create-a-controller","text":"Laminas MVC has several base controller classes for you to start with: AbstractActionController matches routes to methods within this class. For example, if you had a route with the \"list\" action, the \"listAction\" method will be called. AbstractRestfulController determines the HTTP method from the request, and calls a method according to that. For example, a POST HTTP method will call the update() method in the class. You can also create custom controllers by implementing Laminas\\Stdlib\\DispatchableInterface . Learn more about controllers in the chapter on controllers . We will use the AbstractActionController base controller. Create the file src/Application/Controller/HelloController.php . Add the following code: &lt;?php namespace Application\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; // Create an action controller. class HelloController extends AbstractActionController { // Define an action \"world\". public function worldAction() { // Get \"message\" from the query parameters. // In production code, it's a good idea to sanitize user input. $message = $this-&gt;params()-&gt;fromQuery('message', 'hello'); // Pass variables to the view. return new ViewModel(['message' =&gt; $message]); } } By default, this controller will render the view script located in view/application/hello/world.phtml . You can customize this behavior. Learn more about views in the laminas-view documentation .","title":"Create a Controller"},{"location":"quick-start/#create-a-view-script","text":"Create the file view/application/hello/world.phtml and add the following code: &lt;h1&gt;Greetings!&lt;/h1&gt; &lt;p&gt;You said \"&lt;?php echo $this-&gt;escapeHtml($message) ?&gt;\".&lt;/p&gt; Escaping output The method escapeHtml() is a view helper , and it's designed to help mitigate XSS attacks. Never trust user input. If you are at all uncertain about the source of a variable in your view, escape it using one of the view helpers, depending on the type of data.","title":"Create a View Script"},{"location":"quick-start/#create-a-route","text":"Routes determine which controller to call based on the URI and other information from the request. Configure a route and a controller in module/Application/config/module.config.php : return [ 'router' =&gt; [ 'routes' =&gt; [ // Route name: used to generate links, among other things. 'hello-world' =&gt; [ 'type' =&gt; Laminas\\Router\\Http\\Literal::class, // exact match of URI path 'options' =&gt; [ 'route' =&gt; '/hello/world', // URI path 'defaults' =&gt; [ 'controller' =&gt; Application\\Controller\\HelloController::class, // unique name 'action' =&gt; 'world', ], ], ], ], ], 'controllers' =&gt; [ // Tell the application how to instantiate our controller class 'factories' =&gt; [ Application\\Controller\\HelloController::class =&gt; Laminas\\ServiceManager\\Factory\\InvokableFactory::class, ], ], ]; When the URI path of the request matches /hello/world , the specified controller and action will be used. The controller name must be present under the controllers key in the configuration. The associated class will then be instantiated and invoked. Learn more about routing in the laminas-router documentation .","title":"Create a Route"},{"location":"quick-start/#test-it-out","text":"Create a new vhost pointing its document root to the public directory of your application, and fire it up in a browser. You should see the default homepage template of laminas-mvc-skeleton . Append the path /hello/world to your URL and load the page. You should now get the following content: &lt;h1&gt;Greetings!&lt;/h1&gt; &lt;p&gt;You said \"hello\".&lt;/p&gt; Append ?message=welcome to your URL. You should now get: &lt;h1&gt;Greetings!&lt;/h1&gt; &lt;p&gt;You said \"welcome\".&lt;/p&gt; Congratulations! You've created your first Laminas MVC controller!","title":"Test it Out!"},{"location":"quick-start/#learn-more","text":"Creating custom modules Controllers Views Routing","title":"Learn More"},{"location":"routing/","text":"Routing Routing is the act of matching an HTTP request to a given controller. Typically, routing will examine the request URI, and attempt to match the URI path segment against provided constraints. If the constraints match, a set of matches are returned, one of which should be the controller name to execute: 'home' =&gt; [ 'type' =&gt; Laminas\\Router\\Http\\Literal::class, 'options' =&gt; [ 'route' =&gt; '/home', 'defaults' =&gt; [ 'controller' =&gt; Application\\Controller\\IndexController::class, 'action' =&gt; 'index', ], ], ], Routing can utilize other portions of the request URI or environment as well, such as the host or scheme, query parameters, headers, or request method. Configuration File Routing is configured at the module level. For a module Application , the configuration will be located at module/Application/config/module.config.php : return [ 'router' =&gt; [ 'routes' =&gt; [ 'home' =&gt; [ 'type' =&gt; Laminas\\Router\\Http\\Literal::class, 'options' =&gt; [ 'route' =&gt; '/home', 'defaults' =&gt; [ 'controller' =&gt; Application\\Controller\\IndexController::class, 'action' =&gt; 'index', ], ], ], // additional routes ], ], ]; Note that when adding multiple routes, the last route in the list will be checked first. HTTP Route Types Laminas MVC ships with the following HTTP route types: Hostname matches domains and subdomains. Example: docs.laminas.dev . Literal matches an exact URI path. Example: /contact-us Method matches HTTP verbs. Example: post,put for a route that submits a form. Part allows crafting a tree of possible routes based on segments of the URI path. Example: /blog can have child routes with /rss and /subscribe , which would match /blog/rss and /blog/subscribe respectively. Regex matches a URI path using a regular expression. Example: /product/(?&lt;id&gt;[0-9]+) would match /product/001 , with the id parameter containing 001 . Scheme matches the URI scheme. Example: https . Segment matching one or more segments of a URI path. Example: /:blog/:article would match /blog/why-use-mvc , with the article parameter containing why-use-mvc . Learn more about routing in the laminas-router documentation .","title":"Routing"},{"location":"routing/#routing","text":"Routing is the act of matching an HTTP request to a given controller. Typically, routing will examine the request URI, and attempt to match the URI path segment against provided constraints. If the constraints match, a set of matches are returned, one of which should be the controller name to execute: 'home' =&gt; [ 'type' =&gt; Laminas\\Router\\Http\\Literal::class, 'options' =&gt; [ 'route' =&gt; '/home', 'defaults' =&gt; [ 'controller' =&gt; Application\\Controller\\IndexController::class, 'action' =&gt; 'index', ], ], ], Routing can utilize other portions of the request URI or environment as well, such as the host or scheme, query parameters, headers, or request method.","title":"Routing"},{"location":"routing/#configuration-file","text":"Routing is configured at the module level. For a module Application , the configuration will be located at module/Application/config/module.config.php : return [ 'router' =&gt; [ 'routes' =&gt; [ 'home' =&gt; [ 'type' =&gt; Laminas\\Router\\Http\\Literal::class, 'options' =&gt; [ 'route' =&gt; '/home', 'defaults' =&gt; [ 'controller' =&gt; Application\\Controller\\IndexController::class, 'action' =&gt; 'index', ], ], ], // additional routes ], ], ]; Note that when adding multiple routes, the last route in the list will be checked first.","title":"Configuration File"},{"location":"routing/#http-route-types","text":"Laminas MVC ships with the following HTTP route types: Hostname matches domains and subdomains. Example: docs.laminas.dev . Literal matches an exact URI path. Example: /contact-us Method matches HTTP verbs. Example: post,put for a route that submits a form. Part allows crafting a tree of possible routes based on segments of the URI path. Example: /blog can have child routes with /rss and /subscribe , which would match /blog/rss and /blog/subscribe respectively. Regex matches a URI path using a regular expression. Example: /product/(?&lt;id&gt;[0-9]+) would match /product/001 , with the id parameter containing 001 . Scheme matches the URI scheme. Example: https . Segment matching one or more segments of a URI path. Example: /:blog/:article would match /blog/why-use-mvc , with the article parameter containing why-use-mvc . Learn more about routing in the laminas-router documentation .","title":"HTTP Route Types"},{"location":"send-response-event/","text":"The SendResponse Event laminas-mvc defines and utilizes a custom Laminas\\EventManager\\Event for updating the response object prior to emitting it, Laminas\\Mvc\\ResponseSender\\SendResponseEvent . The event allows listeners to set response headers and content. The methods it defines are: setResponse($response) getResponse() setContentSent() contentSent() setHeadersSent() headersSent() Listeners Currently, three listeners are listening to this event at different priorities based on which listener is used most. Class Priority Method Called Description Laminas\\Mvc\\SendResponseListener\\PhpEnvironmentResponseSender -1000 __invoke This is used in HTTP contexts (this is the most often used). Laminas\\Mvc\\SendResponseListener\\ConsoleResponseSender -2000 __invoke This is used in console contexts. Laminas\\Mvc\\SendResponseListener\\SimpleStreamResponseSender -3000 __invoke Because each listener has negative priority, adding your own logic to modify the Response involves adding a new listener without priority (as priority defaults to 1); thus, your own listener will execute before any of the defaults. Triggered By This event is executed when the MvcEvent::FINISH event is triggered, with a priority of -10000.","title":"The SendResponse Event"},{"location":"send-response-event/#the-sendresponse-event","text":"laminas-mvc defines and utilizes a custom Laminas\\EventManager\\Event for updating the response object prior to emitting it, Laminas\\Mvc\\ResponseSender\\SendResponseEvent . The event allows listeners to set response headers and content. The methods it defines are: setResponse($response) getResponse() setContentSent() contentSent() setHeadersSent() headersSent()","title":"The SendResponse Event"},{"location":"send-response-event/#listeners","text":"Currently, three listeners are listening to this event at different priorities based on which listener is used most. Class Priority Method Called Description Laminas\\Mvc\\SendResponseListener\\PhpEnvironmentResponseSender -1000 __invoke This is used in HTTP contexts (this is the most often used). Laminas\\Mvc\\SendResponseListener\\ConsoleResponseSender -2000 __invoke This is used in console contexts. Laminas\\Mvc\\SendResponseListener\\SimpleStreamResponseSender -3000 __invoke Because each listener has negative priority, adding your own logic to modify the Response involves adding a new listener without priority (as priority defaults to 1); thus, your own listener will execute before any of the defaults.","title":"Listeners"},{"location":"send-response-event/#triggered-by","text":"This event is executed when the MvcEvent::FINISH event is triggered, with a priority of -10000.","title":"Triggered By"},{"location":"services/","text":"Default Services The default and recommended way to write laminas-mvc applications uses a set of services defined in the Laminas\\Mvc\\Service namespace. This chapter details what each of those services are, the classes they represent, and the configuration options available. Many of the services are provided by other components, and the factories and abstract factories themselves are defined in the individual components. We will cover those factories in this chapter, however, as usage is generally the same between each. Theory of Operation To allow easy configuration of all the different parts of the MVC system, a somewhat complex set of services and their factories has been created. We'll try to give a simplified explanation of the process. When a Laminas\\Mvc\\Application is created, a Laminas\\ServiceManager\\ServiceManager object is created and configured via Laminas\\Mvc\\Service\\ServiceManagerConfig . The ServiceManagerConfig gets the configuration from config/application.config.php (or some other application configuration you passed to the Application when creating it). From all the service and factories provided in the Laminas\\Mvc\\Service namespace, ServiceManagerConfig is responsible of configuring only three: SharedEventManager , EventManager , and ModuleManager . After this, the Application fetches the ModuleManager . At this point, the ModuleManager further configures the ServiceManager with services and factories provided in Laminas\\Mvc\\Service\\ServiceListenerFactory . This approach allows us to keep the main application configuration concise, and to give the developer the power to configure different parts of the MVC system from within the modules, overriding any default configuration in these MVC services. ServiceManager As a quick review, the following service types may be configured: Invokable services , which map a service name to a class that has no constructor or a constructor that accepts no arguments. Factories , which map a service name to a factory which will create and return an object. A factory receives the service manager as an argument, and may be any PHP callable, or a class or object that implements Laminas\\ServiceManager\\FactoryInterface . Abstract factories , which are factories that can create any number of named services that share the same instantiation pattern; examples include database adapters, cache adapters, loggers, etc. The factory receives the service manager as an argument, the resolved service name, and the requested service name; it must be a class or object implementing Laminas\\ServiceManager\\AbstractFactoryInterface . See the section on abstract factories for configuration information. Aliases , which alias one service name to another. Aliases can also reference other aliases. Initializers , which receive the newly created instance and the service manager, and which can be used to perform additional initialization tasks. The most common use case is to test the instance against specific \"Aware\" interfaces, and, if matching, inject them with the appropriate service. Delegators , which typically decorate retrieval of a service to either substitute an alternate service, decorate the created service, or perform pre/post initialization tasks when creating a service. Lazy services , which are decorators for services with expensive initialization; the service manager essentially returns a proxy service that defers initialization until the first call is made to the service. Plugin managers , which are specialized service managers used to manage objects that are of a related type, such as view helpers, controller plugins, controllers, etc. Plugin managers accept configuration just like service managers, and as such can compose each of the service types listed above. They are also ServiceLocatorAware , and will be injected with the application service manager instance, giving factories and abstract factories access to application-level services when needed. See the heading Plugin managers for a list of available plugin managers. The application service manager is referenced directly during bootstrapping, and has the following services configured out of the box. Invokable services DispatchListener , mapping to Laminas\\Mvc\\DispatchListener . Laminas\\Mvc\\MiddlewareListener . RouteListener , mapping to Laminas\\Mvc\\RouteListener . SendResponseListener , mapping to Laminas\\Mvc\\SendResponseListener . SharedEventManager , mapping to Laminas\\EventManager\\SharedEventManager . Factories Application , mapping to Laminas\\Mvc\\Service\\ApplicationFactory . Config , mapping to Laminas\\Mvc\\Service\\ConfigFactory . Internally, this pulls the ModuleManager service, calls its loadModules() method, and retrieves the merged configuration from the module event. As such, this service contains the entire, merged application configuration. ControllerManager , mapping to Laminas\\Mvc\\Service\\ControllerLoaderFactory . This creates an instance of Laminas\\Mvc\\Controller\\ControllerManager , passing the service manager instance. Additionally, it uses the DiStrictAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve your controllers. If you want to use Laminas\\Di to retrieve your controllers, you must white-list them in your DI configuration under the allowed_controllers key (otherwise, they will just be ignored). The ControllerManager provides initializers for the following: If the controller implements Laminas\\ServiceManager\\ServiceLocatorAwareInterface (or the methods it defines), an instance of the ServiceManager will be injected into it. If the controller implements Laminas\\EventManager\\EventManagerAwareInterface , an instance of the EventManager will be injected into it. Finally, an initializer will inject it with the ControllerPluginManager service, as long as the setPluginManager method is implemented. ControllerPluginManager , mapping to Laminas\\Mvc\\Service\\ControllerPluginManagerFactory . This instantiates the Laminas\\Mvc\\Controller\\PluginManager instance, passing it the service manager instance. It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve your controller plugins . It registers a set of default controller plugins, and contains an initializer for injecting plugins with the current controller. ConsoleAdapter , mapping to Laminas\\Mvc\\Service\\ConsoleAdapterFactory . This grabs the Config service, pulls from the console key, and do the following: If the adapter subkey is present, it is used to get the adapter instance, otherwise, Laminas\\Console\\Console::detectBestAdapter() will be called to configure an adapter instance. If the charset subkey is present, the value is used to set the adapter charset. ConsoleRouter , mapping to Laminas\\Mvc\\Console\\Router\\ConsoleRouterFactory . This grabs the Config service, and pulls from the console key and router subkey, configuring a Laminas\\Mvc\\Console\\Router\\SimpleRouteStack instance. ConsoleViewManager , mapping to Laminas\\Mvc\\Service\\ConsoleViewManagerFactory . This creates and returns an instance of Laminas\\Mvc\\View\\Console\\ViewManager , which in turn registers and initializes a number of console-specific view services. DependencyInjector , mapping to Laminas\\Mvc\\Service\\DiFactory . This pulls the Config service, and looks for a \"di\" key; if found, that value is used to configure a new Laminas\\Di\\Di instance. DiAbstractServiceFactory , mapping to Laminas\\Mvc\\Service\\DiAbstractServiceFactoryFactory . This creates an instance of Laminas\\ServiceManager\\Di\\DiAbstractServiceFactory injecting the Di service instance. That instance is attached to the service manager as an abstract factory, effectively enabling DI as a fallback for providing services. DiServiceInitializer , mapping to Laminas\\Mvc\\Service\\DiServiceInitializerFactory . This creates an instance of Laminas\\ServiceManager\\Di\\DiServiceInitializer injecting the Di service and the service manager itself. DiStrictAbstractServiceFactory , mapping to Laminas\\Mvc\\Service\\DiStrictAbstractServiceFactoryFactory . This creates an instance of Laminas\\Mvc\\Service\\DiStrictAbstractServiceFactoryFactory , injecting the Di service instance. EventManager , mapping to Laminas\\Mvc\\Service\\EventManagerFactory . This factory returns a discrete instance of Laminas\\EventManager\\EventManager on each request. This service is not shared by default, allowing the ability to have an EventManager per service, with a shared SharedEventManager injected in each. FilterManager , mapping to Laminas\\Mvc\\Service\\FilterManagerFactory . This instantiates the Laminas\\Filter\\FilterPluginManager instance, passing it the service manager instance; this is used to manage filters for filter chains . It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve filters. FormElementManager , mapping to Laminas\\Mvc\\Service\\FormElementManagerFactory . This instantiates the Laminas\\Form\\FormElementManager instance, passing it the service manager instance; this is used to manage form elements . It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve form elements. HttpRouter , mapping to Laminas\\Router\\Http\\HttpRouterFactory . This grabs the Config service, and pulls from the router key, configuring a Laminas\\Router\\Http\\TreeRouteStack instance. HttpViewManager , mapping to Laminas\\Mvc\\Service\\HttpViewManagerFactory . This creates and returns an instance of Laminas\\Mvc\\View\\Http\\ViewManager , which in turn registers and initializes a number of HTTP-specific view services. HydratorManager , mapping to Laminas\\Mvc\\Service\\HydratorManagerFactory . This creates and returns an instance of Laminas\\Stdlib\\Hydrator\\HydratorPluginManager , which can be used to manage and persist hydrator instances. InputFilterManager , mapping to Laminas\\Mvc\\Service\\InputFilterManagerFactory . This creates and returns an instance of Laminas\\InputFilter\\InputFilterPluginManager , which can be used to manage and persist input filter instances. ModuleManager , mapping to Laminas\\Mvc\\Service\\ModuleManagerFactory . This is perhaps the most complex factory in the MVC stack. It expects that an ApplicationConfig service has been injected, with keys for module_listener_options and modules ; see the quick start for samples. It creates an instance of Laminas\\ModuleManager\\Listener\\DefaultListenerAggregate , using the module_listener_options retrieved. It then checks if a service with the name ServiceListener exists; if not, it sets a factory with that name mapping to Laminas\\Mvc\\Service\\ServiceListenerFactory . A bunch of service listeners will be added to the ServiceListener , like listeners for the getServiceConfig , getControllerConfig , getControllerPluginConfig , and getViewHelperConfig module methods. Next, it retrieves the EventManager service, and attaches the above listeners. It instantiates a Laminas\\ModuleManager\\ModuleEvent instance, setting the \"ServiceManager\" parameter to the service manager object. Finally, it instantiates a Laminas\\ModuleManager\\ModuleManager instance, and injects the EventManager and ModuleEvent . MvcTranslator , mapping to Laminas\\Mvc\\Service\\TranslatorServiceFactory , and returning an instance of Laminas\\Mvc\\I18n\\Translator , which extends Laminas\\I18n\\Translator\\Translator and implements Laminas\\Validator\\Translator\\TranslatorInterface , allowing the instance to be used anywhere a translator may be required in the framework. PaginatorPluginManager , mapping to Laminas\\Mvc\\Service\\PaginatorPluginManagerFactory . This instantiates the Laminas\\Paginator\\AdapterPluginManager instance, passing it the service manager instance. This is used to manage paginator adapters . It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve paginator adapters. Request , mapping to Laminas\\Mvc\\Service\\RequestFactory . The factory is used to create and return a request instance, according to the current environment. If the current environment is a console environment, it will create a Laminas\\Console\\Request ; otherwise, for HTTP environments, it creates a Laminas\\Http\\PhpEnvironment\\Request . Response , mapping to Laminas\\Mvc\\Service\\ResponseFactory . The factory is used to create and return a response instance, according to the current environment. If the current environment is a console environment, it will create a Laminas\\Console\\Response ; otherwise, for HTTP environments, it creates a Laminas\\Http\\PhpEnvironment\\Response . Router , mapping to Laminas\\Router\\RouterFactory . If in a console environment, it proxies to the ConsoleRouter service; otherwise, it proxies to the HttpRouter service. RoutePluginManager , mapping to Laminas\\Mvc\\Service\\RoutePluginManagerFactory . This instantiates the Laminas\\Router\\RoutePluginManager instance, passing it the service manager instance; this is used to manage route types . It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve route types. SerializerAdapterManager , mapping to Laminas\\Mvc\\Service\\SerializerAdapterPluginManagerFactory , which returns an instance of Laminas\\Serializer\\AdapterPluginManager . This is a plugin manager for managing serializer adapter instances. ServiceListener , mapping to Laminas\\Mvc\\Service\\ServiceListenerFactory . The factory is used to instantiate the ServiceListener , while allowing easy extending. It checks if a service with the name ServiceListenerInterface exists, which must implement Laminas\\ModuleManager\\Listener\\ServiceListenerInterface , before instantiating the default ServiceListener . In addition to this, it retrieves the ApplicationConfig and looks for the service_listener_options key. This allows you to register own listeners for module methods and configuration keys to create an own service manager; see the application configuration options for samples. ValidatorManager , mapping to Laminas\\Mvc\\Service\\ValidatorManagerFactory . This instantiates the Laminas\\Validator\\ValidatorPluginManager instance, passing it the service manager instance. This is used to manage validators . It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve validators. ViewFeedRenderer , mapping to Laminas\\Mvc\\Service\\ViewFeedRendererFactory , which returns an instance of Laminas\\View\\Renderer\\FeedRenderer , used to render feeds. ViewFeedStrategy , mapping to Laminas\\Mvc\\Service\\ViewFeedStrategyFactory , which returns an instance of Laminas\\View\\Strategy\\FeedStrategy , used to select the ViewFeedRenderer given the appropriate criteria. ViewHelperManager , mapping to Laminas\\Mvc\\Service\\ViewHelperManagerFactory , which returns an instance of Laminas\\View\\HelperManager . This is a plugin manager for managing view helper instances. ViewJsonRenderer , mapping to Laminas\\Mvc\\Service\\ViewJsonRendererFactory , which returns an instance of Laminas\\View\\Renderer\\JsonRenderer , used to render JSON structures. ViewJsonStrategy , mapping to Laminas\\Mvc\\Service\\ViewJsonStrategyFactory , which returns an instance of Laminas\\View\\Strategy\\JsonStrategy , used to select the ViewJsonRenderer given the appropriate criteria. ViewManager , mapping to Laminas\\Mvc\\Service\\ViewManagerFactory . The factory is used to create and return a view manager, according to the current environment. If the current environment is a console environment, it will create a Laminas\\Mvc\\View\\Console\\ViewManager ; otherwise, for HTTP environments, it returns a Laminas\\Mvc\\View\\Http\\ViewManager . ViewResolver , mapping to Laminas\\Mvc\\Service\\ViewResolverFactory , which creates and returns the aggregate view resolver. It also attaches the ViewTemplateMapResolver and ViewTemplatePathStack services to it. ViewTemplateMapResolver , mapping to Laminas\\Mvc\\Service\\ViewTemplateMapResolverFactory , which creates, configures and returns the Laminas\\View\\Resolver\\TemplateMapResolver . ViewTemplatePathStack , mapping to Laminas\\Mvc\\Service\\ViewTemplatePathStackFactory , which creates, configures and returns the Laminas\\View\\Resolver\\TemplatePathStack . Abstract factories Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory (opt-in; registered by default in the skeleton application). Laminas\\Db\\Adapter\\AdapterAbstractServiceFactory (opt-in). Laminas\\Form\\FormAbstractServiceFactory is registered by default. Laminas\\Log\\LoggerAbstractServiceFactory (opt-in; registered by default in the skeleton application). Aliases Configuration , mapping to the Config service. Console , mapping to the ConsoleAdapter service. Di , mapping to the DependencyInjector service. MiddlewareListener , mapping to the Laminas\\Mvc\\MiddlewareListener service. Laminas\\Di\\LocatorInterface , mapping to the DependencyInjector service. Laminas\\EventManager\\EventManagerInterface , mapping to the EventManager service. This is mainly to ensure that when falling through to DI, classes are still injected via the ServiceManager . Laminas\\Mvc\\Controller\\PluginManager , mapping to the ControllerPluginManager service. This is mainly to ensure that when falling through to DI, classes are still injected via the ServiceManager . Laminas\\View\\Resolver\\TemplateMapResolver , mapping to the ViewTemplateMapResolver service. Laminas\\View\\Resolver\\TemplatePathStack , mapping to the ViewTemplatePathStack service. Laminas\\View\\Resolver\\AggregateResolver , mapping to the ViewResolver service. Laminas\\View\\Resolver\\ResolverInterface , mapping to the ViewResolver service. Initializers For objects that implement Laminas\\EventManager\\EventManagerAwareInterface , the EventManager service will be retrieved and injected. This service is not shared, though each instance it creates is injected with a shared instance of SharedEventManager . For objects that implement Laminas\\ServiceManager\\ServiceLocatorAwareInterface (or the methods it defines), the ServiceManager will inject itself into the object. The ServiceManager registers itself as the ServiceManager service, and aliases itself to the class names Laminas\\ServiceManager\\ServiceLocatorInterface and Laminas\\ServiceManager\\ServiceManager . Abstract Factories As noted in the previous section, Laminas provides a number of abstract service factories by default. Each is noted below, along with sample configuration. In each instance, the abstract factory looks for a top-level configuration key, consisting of key/value pairs where the key is the service name, and the value is the configuration to use to create the given service. Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory This abstract factory is opt-in, but registered by default in the skeleton application. It uses the top-level configuration key \"caches\". return [ 'caches' =&gt; [ 'Cache\\Transient' =&gt; [ 'adapter' =&gt; 'redis', 'ttl' =&gt; 60, 'plugins' =&gt; [ 'exception_handler' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ], 'Cache\\Persistence' =&gt; [ 'adapter' =&gt; 'filesystem', 'ttl' =&gt; 86400, ], ], ]; See the cache documentation for more configuration options. Laminas\\Db\\Adapter\\AdapterAbstractServiceFactory This abstract factory is opt-in. It uses the top-level configuration key \"db\", with a subkey \"adapters\". return [ 'db' =&gt; ['adapters' =&gt; [ 'Db\\ReadOnly' =&gt; [ 'driver' =&gt; 'Pdo_Sqlite', 'database' =&gt; 'data/db/users.db', ], 'Db\\Writeable' =&gt; [ 'driver' =&gt; 'Mysqli', 'database' =&gt; 'users', 'username' =&gt; 'developer', 'password' =&gt; 'developer_password', ], ]], ]; See the DB adapter documentation for more configuration options. Laminas\\Form\\FormAbstractServiceFactory This abstract factory is registered by default. It uses the top-level configuration key \"forms\". It makes use of the FilterManager , FormElementManager , HydratorManager , InputFilterManager , and ValidatorManager plugin managers in order to allow instantiation and creation of form objects and all related objects in the form hierarchy. return [ 'forms' =&gt; [ 'Form\\Foo' =&gt; [ 'hydrator' =&gt; 'ObjectProperty', 'type' =&gt; 'Laminas\\Form\\Form', 'elements' =&gt; [ [ 'spec' =&gt; [ 'type' =&gt; 'Laminas\\Form\\Element\\Email', 'name' =&gt; 'email', 'options' =&gt; [ 'label' =&gt; 'Your email address', ], ], ], ], ], ], ]; Form configuration follows the same configuration you would use with a form factory; the primary difference is that all plugin managers have already been injected for you, allowing you the possibility of custom objects or substitutions. See the form factory documentation for more configuration options. Laminas\\Log\\LoggerAbstractServiceFactory This abstract factory is opt-in, but registered by default in the skeleton application. It uses the top-level configuration key \"log\". return [ 'log' =&gt; [ 'Log\\App' =&gt; [ 'writers' =&gt; [ [ 'name' =&gt; 'stream', 'priority' =&gt; 1000, 'options' =&gt; [ 'stream' =&gt; 'data/logs/app.log', ], ], ], ], ], ]; See the log documentation for more configuration options. Plugin Managers The following plugin managers are configured by default: ControllerManager , corresponding to Laminas\\Mvc\\Controller\\ControllerManager , and used to manage controller instances. ControllerPluginManager , corresponding to Laminas\\Mvc\\Controller\\PluginManager , and used to manage controller plugin instances. FilterManager , corresponding to Laminas\\Filter\\FilterPluginManager , and used to manage filter instances. FormElementManager , corresponding to Laminas\\Form\\FormElementManager , and used to manage instances of form elements and fieldsets. HydratorManager , corresponding to Laminas\\Stdlib\\Hydrator\\HydratorPluginManager , and used to manage hydrator instances. InputFilterManager , corresponding to Laminas\\InputFilter\\InputFilterPluginManager , and used to manage input filter instances. RoutePluginManager , corresponding to Laminas\\Router\\RoutePluginManager , and used to manage route instances. SerializerAdapterManager , corresponding to Laminas\\Serializer\\AdapterPluginManager , and used to manage serializer instances. ValidatorManager , corresponding to Laminas\\Validator\\ValidatorPluginManager , and used to manage validator instances. ViewHelperManager , corresponding to Laminas\\View\\HelperPluginManager , and used to manage view helper instances. As noted in the previous section, all plugin managers share the same configuration and service types as the standard service manager; they are simply scoped, and only allow instances of certain types to be created or registered. Default types available are listed in the documentation for each component. ViewManager The View layer within laminas-mvc consists of a large number of collaborators and event listeners. As such, Laminas\\Mvc\\View\\ViewManager was created to handle creation of the various objects, as well as wiring them together and establishing event listeners. The ViewManager itself is an event listener on the bootstrap event. It retrieves the ServiceManager from the Application object, as well as its composed EventManager . Configuration for all members of the ViewManager fall under the view_manager configuration key, and expect values as noted below. The following services are created and managed by the ViewManager : ViewHelperManager , representing and aliased to Laminas\\View\\HelperPluginManager . It is seeded with the ServiceManager . Created via the Laminas\\Mvc\\Service\\ViewHelperManagerFactory . The Router service is retrieved, and injected into the Url helper. If the base_path key is present, it is used to inject the BasePath view helper; otherwise, the Request service is retrieved, and the value of its getBasePath() method is used. If the base_path_console key is present, it is used to inject the BasePath view helper for console requests; otherwise, the Request service is retrieved, and the value of its getBasePath() method is used. This can be useful for sending urls in emails via a cronjob. If the doctype key is present, it will be used to set the value of the Doctype view helper. ViewTemplateMapResolver , representing and aliased to Laminas\\View\\Resolver\\TemplateMapResolver . If a template_map key is present, it will be used to seed the template map. ViewTemplatePathStack , representing and aliased to Laminas\\View\\Resolver\\TemplatePathStack . If a template_path_stack key is present, it will be used to seed the stack. If a default_template_suffix key is present, it will be used as the default suffix for template scripts resolving. ViewResolver , representing and aliased to Laminas\\View\\Resolver\\AggregateResolver and Laminas\\View\\Resolver\\ResolverInterface . It is seeded with the ViewTemplateMapResolver and ViewTemplatePathStack services as resolvers. ViewRenderer , representing and aliased to Laminas\\View\\Renderer\\PhpRenderer and Laminas\\View\\Renderer\\RendererInterface . It is seeded with the ViewResolver and ViewHelperManager services. Additionally, the ViewModel helper gets seeded with the ViewModel as its root (layout) model. ViewPhpRendererStrategy , representing and aliased to Laminas\\View\\Strategy\\PhpRendererStrategy . It gets seeded with the ViewRenderer service. View , representing and aliased to Laminas\\View\\View . It gets seeded with the EventManager service, and attaches the ViewPhpRendererStrategy as an aggregate listener. DefaultRenderingStrategy , representing and aliased to Laminas\\Mvc\\View\\DefaultRenderingStrategy . If the layout key is present, it is used to seed the strategy's layout template. It is seeded with the View service. ExceptionStrategy , representing and aliased to Laminas\\Mvc\\View\\ExceptionStrategy . If the display_exceptions or exception_template keys are present, they are used to configure the strategy. RouteNotFoundStrategy , representing and aliased to Laminas\\Mvc\\View\\RouteNotFoundStrategy and 404Strategy . If the display_not_found_reason or not_found_template keys are present, they are used to configure the strategy. ViewModel . In this case, no service is registered; the ViewModel is retrieved from the MvcEvent and injected with the layout template name. The ViewManager also creates several other listeners, but does not expose them as services; these include Laminas\\Mvc\\View\\CreateViewModelListener , Laminas\\Mvc\\View\\InjectTemplateListener , and Laminas\\Mvc\\View\\InjectViewModelListener . These, along with RouteNotFoundStrategy , ExceptionStrategy , and DefaultRenderingStrategy are attached as listeners either to the application EventManager instance or the SharedEventManager instance. Finally, if you have a strategies key in your configuration, the ViewManager will loop over these and attach them in order to the View service as listeners, at a priority of 100 (allowing them to execute before the DefaultRenderingStrategy ). Application Configuration Options The following options may be used to provide initial configuration for the ServiceManager , ModuleManager , and Application instances, allowing them to then find and aggregate the configuration used for the Config service, which is intended for configuring all other objects in the system. These configuration directives go to the config/application.config.php file. &lt;?php return [ // This should be an array of module namespaces used in the application. 'modules' =&gt; [ ], // These are various options for the listeners attached to the ModuleManager 'module_listener_options' =&gt; [ // This should be an array of paths in which modules reside. // If a string key is provided, the listener will consider that a module // namespace, the value of that key the specific path to that module's // Module class. 'module_paths' =&gt; [ ], // An array of paths from which to glob configuration files after // modules are loaded. These effectively override configuration // provided by modules themselves. Paths may use GLOB_BRACE notation. 'config_glob_paths' =&gt; [ ], // Whether or not to enable a configuration cache. // If enabled, the merged configuration will be cached and used in // subsequent requests. 'config_cache_enabled' =&gt; $booleanValue, // The key used to create the configuration cache file name. 'config_cache_key' =&gt; $stringKey, // Whether or not to enable a module class map cache. // If enabled, creates a module class map cache which will be used // by in future requests, to reduce the autoloading process. 'module_map_cache_enabled' =&gt; $booleanValue, // The key used to create the class map cache file name. 'module_map_cache_key' =&gt; $stringKey, // The path in which to cache merged configuration. 'cache_dir' =&gt; $stringPath, // Whether or not to enable modules dependency checking. // Enabled by default, prevents usage of modules that depend on other modules // that weren't loaded. 'check_dependencies' =&gt; $booleanValue, ], // Used to create an own service manager. May contain one or more child arrays. 'service_listener_options' =&gt; [ [ 'service_manager' =&gt; $stringServiceManagerName, 'config_key' =&gt; $stringConfigKey, 'interface' =&gt; $stringOptionalInterface, 'method' =&gt; $stringRequiredMethodName, ], ] // Initial configuration with which to seed the ServiceManager. // Should be compatible with Laminas\\ServiceManager\\Config. 'service_manager' =&gt; [ ], ]; For an example, see the laminas-mvc-skeleton configuration file . Default Configuration Options The following options are available when using the default services configured by the ServiceManagerConfig and ViewManager . These configuration directives can go to the config/autoload/{{,*.}global,{,*.}local}.php files, or in the module/&lt;module name&gt;/config/module.config.php configuration files. The merging of these configuration files is done by the ModuleManager . It first merges each module's module.config.php file, and then the files in config/autoload (first the *.global.php and then the *.local.php files). The order of the merge is relevant so you can override a module's configuration with your application configuration. If you have both a config/autoload/my.global.config.php and config/autoload/my.local.config.php , the local configuration file overrides the global configuration. Do not commit local configuration Local configuration files are intended to keep sensitive information, such as database credentials, and as such, it is highly recommended to keep these local configuration files out of your VCS. The laminas-mvc-skeleton 's config/autoload/.gitignore file ignores *.local.php files by default. &lt;?php return [ // The following are used to configure controller loader // Should be compatible with Laminas\\ServiceManager\\Config. 'controllers' =&gt; [ // Map of controller \"name\" to class // This should be used if you do not need to inject any dependencies // in your controller 'invokables' =&gt; [ ], // Map of controller \"name\" to factory for creating controller instance // You may provide either the class name of a factory, or a PHP callback. 'factories' =&gt; [ ], ], // The following are used to configure controller plugin loader // Should be compatible with Laminas\\ServiceManager\\Config. 'controller_plugins' =&gt; [ ], // The following are used to configure view helper manager // Should be compatible with Laminas\\ServiceManager\\Config. 'view_helpers' =&gt; [ ], // The following is used to configure a Laminas\\Di\\Di instance. // The array should be in a format that Laminas\\Di\\Config can understand. 'di' =&gt; [ ], // Configuration for the Router service // Can contain any router configuration, but typically will always define // the routes for the application. See the router documentation for details // on route configuration. 'router' =&gt; [ 'routes' =&gt; [ ], ], // ViewManager configuration 'view_manager' =&gt; [ // Base URL path to the application 'base_path' =&gt; $stringBasePath, // Doctype with which to seed the Doctype helper 'doctype' =&gt; $doctypeHelperConstantString, // e.g. HTML5, XHTML1 // TemplateMapResolver configuration // template/path pairs 'template_map' =&gt; [ ], // TemplatePathStack configuration // module/view script path pairs 'template_path_stack' =&gt; [ ], // Default suffix to use when resolving template scripts, if none, 'phtml' is used 'default_template_suffix' =&gt; $templateSuffix, // e.g. 'php' // Controller namespace to template map 'controller_map' =&gt; [ ], // Layout template name 'layout' =&gt; $layoutTemplateName, // e.g. 'layout/layout' // ExceptionStrategy configuration 'display_exceptions' =&gt; $bool, // display exceptions in template 'exception_template' =&gt; $stringTemplateName, // e.g. 'error' // RouteNotFoundStrategy configuration 'display_not_found_reason' =&gt; $bool, // display 404 reason in template 'not_found_template' =&gt; $stringTemplateName, // e.g. '404' // Additional strategies to attach // These should be class names or service names of View strategy classes // that act as ListenerAggregates. They will be attached at priority 100, // in the order registered. 'strategies' =&gt; [ 'ViewJsonStrategy', // register JSON renderer strategy 'ViewFeedStrategy', // register Feed renderer strategy ], ], ]; For an example, see the Application module configuration file in the laminas-mvc-skeleton.","title":"Default Services"},{"location":"services/#default-services","text":"The default and recommended way to write laminas-mvc applications uses a set of services defined in the Laminas\\Mvc\\Service namespace. This chapter details what each of those services are, the classes they represent, and the configuration options available. Many of the services are provided by other components, and the factories and abstract factories themselves are defined in the individual components. We will cover those factories in this chapter, however, as usage is generally the same between each.","title":"Default Services"},{"location":"services/#theory-of-operation","text":"To allow easy configuration of all the different parts of the MVC system, a somewhat complex set of services and their factories has been created. We'll try to give a simplified explanation of the process. When a Laminas\\Mvc\\Application is created, a Laminas\\ServiceManager\\ServiceManager object is created and configured via Laminas\\Mvc\\Service\\ServiceManagerConfig . The ServiceManagerConfig gets the configuration from config/application.config.php (or some other application configuration you passed to the Application when creating it). From all the service and factories provided in the Laminas\\Mvc\\Service namespace, ServiceManagerConfig is responsible of configuring only three: SharedEventManager , EventManager , and ModuleManager . After this, the Application fetches the ModuleManager . At this point, the ModuleManager further configures the ServiceManager with services and factories provided in Laminas\\Mvc\\Service\\ServiceListenerFactory . This approach allows us to keep the main application configuration concise, and to give the developer the power to configure different parts of the MVC system from within the modules, overriding any default configuration in these MVC services.","title":"Theory of Operation"},{"location":"services/#servicemanager","text":"As a quick review, the following service types may be configured: Invokable services , which map a service name to a class that has no constructor or a constructor that accepts no arguments. Factories , which map a service name to a factory which will create and return an object. A factory receives the service manager as an argument, and may be any PHP callable, or a class or object that implements Laminas\\ServiceManager\\FactoryInterface . Abstract factories , which are factories that can create any number of named services that share the same instantiation pattern; examples include database adapters, cache adapters, loggers, etc. The factory receives the service manager as an argument, the resolved service name, and the requested service name; it must be a class or object implementing Laminas\\ServiceManager\\AbstractFactoryInterface . See the section on abstract factories for configuration information. Aliases , which alias one service name to another. Aliases can also reference other aliases. Initializers , which receive the newly created instance and the service manager, and which can be used to perform additional initialization tasks. The most common use case is to test the instance against specific \"Aware\" interfaces, and, if matching, inject them with the appropriate service. Delegators , which typically decorate retrieval of a service to either substitute an alternate service, decorate the created service, or perform pre/post initialization tasks when creating a service. Lazy services , which are decorators for services with expensive initialization; the service manager essentially returns a proxy service that defers initialization until the first call is made to the service. Plugin managers , which are specialized service managers used to manage objects that are of a related type, such as view helpers, controller plugins, controllers, etc. Plugin managers accept configuration just like service managers, and as such can compose each of the service types listed above. They are also ServiceLocatorAware , and will be injected with the application service manager instance, giving factories and abstract factories access to application-level services when needed. See the heading Plugin managers for a list of available plugin managers. The application service manager is referenced directly during bootstrapping, and has the following services configured out of the box.","title":"ServiceManager"},{"location":"services/#abstract-factories_1","text":"As noted in the previous section, Laminas provides a number of abstract service factories by default. Each is noted below, along with sample configuration. In each instance, the abstract factory looks for a top-level configuration key, consisting of key/value pairs where the key is the service name, and the value is the configuration to use to create the given service.","title":"Abstract Factories"},{"location":"services/#plugin-managers","text":"The following plugin managers are configured by default: ControllerManager , corresponding to Laminas\\Mvc\\Controller\\ControllerManager , and used to manage controller instances. ControllerPluginManager , corresponding to Laminas\\Mvc\\Controller\\PluginManager , and used to manage controller plugin instances. FilterManager , corresponding to Laminas\\Filter\\FilterPluginManager , and used to manage filter instances. FormElementManager , corresponding to Laminas\\Form\\FormElementManager , and used to manage instances of form elements and fieldsets. HydratorManager , corresponding to Laminas\\Stdlib\\Hydrator\\HydratorPluginManager , and used to manage hydrator instances. InputFilterManager , corresponding to Laminas\\InputFilter\\InputFilterPluginManager , and used to manage input filter instances. RoutePluginManager , corresponding to Laminas\\Router\\RoutePluginManager , and used to manage route instances. SerializerAdapterManager , corresponding to Laminas\\Serializer\\AdapterPluginManager , and used to manage serializer instances. ValidatorManager , corresponding to Laminas\\Validator\\ValidatorPluginManager , and used to manage validator instances. ViewHelperManager , corresponding to Laminas\\View\\HelperPluginManager , and used to manage view helper instances. As noted in the previous section, all plugin managers share the same configuration and service types as the standard service manager; they are simply scoped, and only allow instances of certain types to be created or registered. Default types available are listed in the documentation for each component.","title":"Plugin Managers"},{"location":"services/#viewmanager","text":"The View layer within laminas-mvc consists of a large number of collaborators and event listeners. As such, Laminas\\Mvc\\View\\ViewManager was created to handle creation of the various objects, as well as wiring them together and establishing event listeners. The ViewManager itself is an event listener on the bootstrap event. It retrieves the ServiceManager from the Application object, as well as its composed EventManager . Configuration for all members of the ViewManager fall under the view_manager configuration key, and expect values as noted below. The following services are created and managed by the ViewManager : ViewHelperManager , representing and aliased to Laminas\\View\\HelperPluginManager . It is seeded with the ServiceManager . Created via the Laminas\\Mvc\\Service\\ViewHelperManagerFactory . The Router service is retrieved, and injected into the Url helper. If the base_path key is present, it is used to inject the BasePath view helper; otherwise, the Request service is retrieved, and the value of its getBasePath() method is used. If the base_path_console key is present, it is used to inject the BasePath view helper for console requests; otherwise, the Request service is retrieved, and the value of its getBasePath() method is used. This can be useful for sending urls in emails via a cronjob. If the doctype key is present, it will be used to set the value of the Doctype view helper. ViewTemplateMapResolver , representing and aliased to Laminas\\View\\Resolver\\TemplateMapResolver . If a template_map key is present, it will be used to seed the template map. ViewTemplatePathStack , representing and aliased to Laminas\\View\\Resolver\\TemplatePathStack . If a template_path_stack key is present, it will be used to seed the stack. If a default_template_suffix key is present, it will be used as the default suffix for template scripts resolving. ViewResolver , representing and aliased to Laminas\\View\\Resolver\\AggregateResolver and Laminas\\View\\Resolver\\ResolverInterface . It is seeded with the ViewTemplateMapResolver and ViewTemplatePathStack services as resolvers. ViewRenderer , representing and aliased to Laminas\\View\\Renderer\\PhpRenderer and Laminas\\View\\Renderer\\RendererInterface . It is seeded with the ViewResolver and ViewHelperManager services. Additionally, the ViewModel helper gets seeded with the ViewModel as its root (layout) model. ViewPhpRendererStrategy , representing and aliased to Laminas\\View\\Strategy\\PhpRendererStrategy . It gets seeded with the ViewRenderer service. View , representing and aliased to Laminas\\View\\View . It gets seeded with the EventManager service, and attaches the ViewPhpRendererStrategy as an aggregate listener. DefaultRenderingStrategy , representing and aliased to Laminas\\Mvc\\View\\DefaultRenderingStrategy . If the layout key is present, it is used to seed the strategy's layout template. It is seeded with the View service. ExceptionStrategy , representing and aliased to Laminas\\Mvc\\View\\ExceptionStrategy . If the display_exceptions or exception_template keys are present, they are used to configure the strategy. RouteNotFoundStrategy , representing and aliased to Laminas\\Mvc\\View\\RouteNotFoundStrategy and 404Strategy . If the display_not_found_reason or not_found_template keys are present, they are used to configure the strategy. ViewModel . In this case, no service is registered; the ViewModel is retrieved from the MvcEvent and injected with the layout template name. The ViewManager also creates several other listeners, but does not expose them as services; these include Laminas\\Mvc\\View\\CreateViewModelListener , Laminas\\Mvc\\View\\InjectTemplateListener , and Laminas\\Mvc\\View\\InjectViewModelListener . These, along with RouteNotFoundStrategy , ExceptionStrategy , and DefaultRenderingStrategy are attached as listeners either to the application EventManager instance or the SharedEventManager instance. Finally, if you have a strategies key in your configuration, the ViewManager will loop over these and attach them in order to the View service as listeners, at a priority of 100 (allowing them to execute before the DefaultRenderingStrategy ).","title":"ViewManager"},{"location":"services/#application-configuration-options","text":"The following options may be used to provide initial configuration for the ServiceManager , ModuleManager , and Application instances, allowing them to then find and aggregate the configuration used for the Config service, which is intended for configuring all other objects in the system. These configuration directives go to the config/application.config.php file. &lt;?php return [ // This should be an array of module namespaces used in the application. 'modules' =&gt; [ ], // These are various options for the listeners attached to the ModuleManager 'module_listener_options' =&gt; [ // This should be an array of paths in which modules reside. // If a string key is provided, the listener will consider that a module // namespace, the value of that key the specific path to that module's // Module class. 'module_paths' =&gt; [ ], // An array of paths from which to glob configuration files after // modules are loaded. These effectively override configuration // provided by modules themselves. Paths may use GLOB_BRACE notation. 'config_glob_paths' =&gt; [ ], // Whether or not to enable a configuration cache. // If enabled, the merged configuration will be cached and used in // subsequent requests. 'config_cache_enabled' =&gt; $booleanValue, // The key used to create the configuration cache file name. 'config_cache_key' =&gt; $stringKey, // Whether or not to enable a module class map cache. // If enabled, creates a module class map cache which will be used // by in future requests, to reduce the autoloading process. 'module_map_cache_enabled' =&gt; $booleanValue, // The key used to create the class map cache file name. 'module_map_cache_key' =&gt; $stringKey, // The path in which to cache merged configuration. 'cache_dir' =&gt; $stringPath, // Whether or not to enable modules dependency checking. // Enabled by default, prevents usage of modules that depend on other modules // that weren't loaded. 'check_dependencies' =&gt; $booleanValue, ], // Used to create an own service manager. May contain one or more child arrays. 'service_listener_options' =&gt; [ [ 'service_manager' =&gt; $stringServiceManagerName, 'config_key' =&gt; $stringConfigKey, 'interface' =&gt; $stringOptionalInterface, 'method' =&gt; $stringRequiredMethodName, ], ] // Initial configuration with which to seed the ServiceManager. // Should be compatible with Laminas\\ServiceManager\\Config. 'service_manager' =&gt; [ ], ]; For an example, see the laminas-mvc-skeleton configuration file .","title":"Application Configuration Options"},{"location":"services/#default-configuration-options","text":"The following options are available when using the default services configured by the ServiceManagerConfig and ViewManager . These configuration directives can go to the config/autoload/{{,*.}global,{,*.}local}.php files, or in the module/&lt;module name&gt;/config/module.config.php configuration files. The merging of these configuration files is done by the ModuleManager . It first merges each module's module.config.php file, and then the files in config/autoload (first the *.global.php and then the *.local.php files). The order of the merge is relevant so you can override a module's configuration with your application configuration. If you have both a config/autoload/my.global.config.php and config/autoload/my.local.config.php , the local configuration file overrides the global configuration.","title":"Default Configuration Options"},{"location":"cookbook/automating-controller-factories/","text":"Automating Controller Factories Writing a factory class for each and every controller that has dependencies can be tedious, particularly in early development as you are still sorting out dependencies. As of version 3.0.1, laminas-mvc ships with Laminas\\Mvc\\Controller\\LazyControllerAbstractFactory , which provides a reflection-based approach to controller instantiation, resolving constructor dependencies to the relevant services. The factory may be used as either an abstract factory, or mapped to specific controller names as a factory: use Laminas\\Mvc\\Controller\\LazyControllerAbstractFactory; return [ /* ... */ 'controllers' =&gt; [ 'abstract_factories' =&gt; [ LazyControllerAbstractFactory::class, ], 'factories' =&gt; [ 'MyModule\\Controller\\FooController' =&gt; LazyControllerAbstractFactory::class, ], ], /* ... */ ]; Mapping controllers to the factory is more explicit and performant. The factory operates with the following constraints/features: A parameter named $config typehinted as an array will receive the application \"config\" service (i.e., the merged configuration). Parameters typehinted against array, but not named $config , will be injected with an empty array. Scalar parameters will be resolved as null values. If a service cannot be found for a given typehint, the factory will raise an exception detailing this. Some services provided by Laminas components do not have entries based on their class name (for historical reasons); the factory contains a map of these class/interface names to the corresponding service name to allow them to resolve. These include: Laminas\\Console\\Adapter\\AdapterInterface maps to ConsoleAdapter , Laminas\\Filter\\FilterPluginManager maps to FilterManager , Laminas\\Hydrator\\HydratorPluginManager maps to HydratorManager , Laminas\\InputFilter\\InputFilterPluginManager maps to InputFilterManager , Laminas\\Log\\FilterPluginManager maps to LogFilterManager , Laminas\\Log\\FormatterPluginManager maps to LogFormatterManager , Laminas\\Log\\ProcessorPluginManager maps to LogProcessorManager , Laminas\\Log\\WriterPluginManager maps to LogWriterManager , Laminas\\Serializer\\AdapterPluginManager maps to SerializerAdapterManager , Laminas\\Validator\\ValidatorPluginManager maps to ValidatorManager , $options passed to the factory are ignored in all cases, as we cannot make assumptions about which argument(s) they might replace. Once your dependencies have stabilized, we recommend writing a dedicated factory, as reflection can introduce performance overhead. References This feature was inspired by a blog post by Alexandre Lemaire .","title":"Automating controller factories"},{"location":"cookbook/automating-controller-factories/#automating-controller-factories","text":"Writing a factory class for each and every controller that has dependencies can be tedious, particularly in early development as you are still sorting out dependencies. As of version 3.0.1, laminas-mvc ships with Laminas\\Mvc\\Controller\\LazyControllerAbstractFactory , which provides a reflection-based approach to controller instantiation, resolving constructor dependencies to the relevant services. The factory may be used as either an abstract factory, or mapped to specific controller names as a factory: use Laminas\\Mvc\\Controller\\LazyControllerAbstractFactory; return [ /* ... */ 'controllers' =&gt; [ 'abstract_factories' =&gt; [ LazyControllerAbstractFactory::class, ], 'factories' =&gt; [ 'MyModule\\Controller\\FooController' =&gt; LazyControllerAbstractFactory::class, ], ], /* ... */ ]; Mapping controllers to the factory is more explicit and performant. The factory operates with the following constraints/features: A parameter named $config typehinted as an array will receive the application \"config\" service (i.e., the merged configuration). Parameters typehinted against array, but not named $config , will be injected with an empty array. Scalar parameters will be resolved as null values. If a service cannot be found for a given typehint, the factory will raise an exception detailing this. Some services provided by Laminas components do not have entries based on their class name (for historical reasons); the factory contains a map of these class/interface names to the corresponding service name to allow them to resolve. These include: Laminas\\Console\\Adapter\\AdapterInterface maps to ConsoleAdapter , Laminas\\Filter\\FilterPluginManager maps to FilterManager , Laminas\\Hydrator\\HydratorPluginManager maps to HydratorManager , Laminas\\InputFilter\\InputFilterPluginManager maps to InputFilterManager , Laminas\\Log\\FilterPluginManager maps to LogFilterManager , Laminas\\Log\\FormatterPluginManager maps to LogFormatterManager , Laminas\\Log\\ProcessorPluginManager maps to LogProcessorManager , Laminas\\Log\\WriterPluginManager maps to LogWriterManager , Laminas\\Serializer\\AdapterPluginManager maps to SerializerAdapterManager , Laminas\\Validator\\ValidatorPluginManager maps to ValidatorManager , $options passed to the factory are ignored in all cases, as we cannot make assumptions about which argument(s) they might replace. Once your dependencies have stabilized, we recommend writing a dedicated factory, as reflection can introduce performance overhead.","title":"Automating Controller Factories"},{"location":"cookbook/automating-controller-factories/#references","text":"This feature was inspired by a blog post by Alexandre Lemaire .","title":"References"},{"location":"migration/","text":"Migration While we strive to keep functionality backwards compatible between releases, occasionally we need to break features in order to fix critical or security issues. Additionally, in order to signal upcoming changes, we will introduce deprecation notices or add forwards-compatibility features to assist you in migration. The chapters in this section document these changes. Migrating from v2.X to v2.7 Migrating to v3.0","title":"Migration Overview"},{"location":"migration/#migration","text":"While we strive to keep functionality backwards compatible between releases, occasionally we need to break features in order to fix critical or security issues. Additionally, in order to signal upcoming changes, we will introduce deprecation notices or add forwards-compatibility features to assist you in migration. The chapters in this section document these changes. Migrating from v2.X to v2.7 Migrating to v3.0","title":"Migration"},{"location":"migration/to-v2-7/","text":"Upgrading to 2.7 Middleware laminas-mvc now registers Laminas\\Mvc\\MiddlewareListener as a dispatch listener at a priority higher than Laminas\\Mvc\\DispatchListener , allowing dispatch of PSR-7 middleware. Read the middleware chapter for details on how to use this new feature. Application The constructor signature of Laminas\\Mvc\\Application has changed. Previously, it was: __construct($configuration, ServiceManager $serviceManager) and internally, it pulled the services EventManager , Request , and Response from the provided $serviceManager during initialization. The new constructor signature provides optional arguments for injecting the event manager, request, and response: __construct( $configuration, ServiceManager $serviceManager, EventManager $events = null, RequestInterface $request = null, ResponseInterface $response = null ) This change makes all dependencies explicit. Starting in v3.0, the new arguments will be required . The factory Laminas\\Mvc\\Service\\ApplicationFactory was updated to follow the new signature. This change should only affect users who are manually instantiating the Application instance. EventManagerAware initializers laminas-mvc provides two mechanisms for injecting event managers into EventManagerAware objects. One is the \"EventManagerAwareInitializer\" registered in Laminas\\Mvc\\Service\\ServiceManagerConfig , and the other is the Laminas\\Mvc\\Controller\\ControllerManager::injectEventManager() initializer. In both cases, the logic was updated to be forwards compatible with laminas-eventmanager v3. Previously each would check if the instance's getEventManager() method returned an event manager instance, and, if so, inject the shared event manager: $events = $instance-&gt;getEventManager(); if ($events instanceof EventManagerInterface) { $events-&gt;setSharedManager($container-&gt;get('SharedEventManager')); } In laminas-eventmanager v3, event managers are now injected with the shared manager at instantiation, and no setter exists for providing the shared manager. As such, the above logic changed to: $events = $instance-&gt;getEventManager(); if (! $events || ! $events-&gt;getSharedManager()) { $instance-&gt;setEventManager($container-&gt;get('EventManager')); } In other words, it re-injects with a new event manager instance if the instance pulled does not have a shared manager composed. This likely will not cause regressions in existing code, but may be something to be aware of if you were previously depending on lazy-loaded event manager state. ServiceLocatorAware initializers laminas-servicemanager v3.0 removes Laminas\\ServiceManager\\ServiceLocatorAwareInterface . Since laminas-mvc provides initializers around that interface, they needed updates to allow both forwards compatibility with laminas-servicemanager v3 as well as backwards compatibility with existing applications. This was accomplished in two ways: The abstract controller implementations no longer implement ServiceLocatorAwareInterface , but continue to define the methods that the interface defines (namely setServiceLocator() and getServiceLocator() . The initializers registered by Laminas\\Mvc\\Service\\ServiceManagerConfig and Laminas\\Mvc\\Controller\\ControllerManager now use duck-typing to determine if an instance requires container injection; if so it will do so. However, we also maintain that service locator injection is an anti-pattern; dependencies should be injected directly into instances instead. As such, starting in 2.7.0, we now emit a deprecation notice any time an instance is injected by one of these initializers, and we plan to remove the initializers for version 3.0. The deprecation notice includes the name of the class, to help you identify what instances you will need to update before the laminas-mvc v3 release. To prepare your code, you will need to do the following within your controller: Find all cases where you call getServiceLocator() , and identify the services they retrieve. Update your controller to accept these services via the constructor. If you have not already, create a factory class for your controller. In the factory, pull the appropriate services and pass them to the controller's constructor. As an example, consider the following code from a controller: $db = $this-&gt;getServiceLcoator()-&gt;get('Db\\ApplicationAdapter'); To update your controller, you will: Add a $db property to your class. Update the constructor to accept the database adapter and assign it to the $db property. Change the above line to either read $db = $this-&gt;db; or just use the property directly . Add a factory that pulls the service and pushes it into the controller. The controller then might look like the following: use Laminas\\Db\\Adapter\\AdapterInterface; use Laminas\\Mvc\\Controller\\AbstractActionController; class YourController extends AbstractActionController { private $db; public function __construct(AdapterInterface $db) { $this-&gt;db = $db; } public function someAction() { $results = $this-&gt;db-&gt;query(/* ... */); /* ... */ } } A factory would look like the following: use Interop\\Container\\ContainerInterface; class YourControllerFactory { public function __invoke(ContainerInterface $container) { return new YourController($container-&gt;get('Db\\ApplicationAdapter')); } } You then also need to ensure the controller manager knows about the factory. It likely already does, as an invokable; you will redefine it as a factory in your module.config.php : return [ 'controllers' =&gt; [ 'factories' =&gt; [ YourController::class =&gt; YourControllerFactory::class, /* ... */ ], /* ... */ ], /* ... */ ]; While this may seem like more steps, doing so ensures your code has no hidden dependencies, improves the testability of your code, and allows you to substitute alternatives for either the dependencies or the controller itself. Optional dependencies In some cases, you may have dependencies that are only required for some execution paths, such as forms, database adapters, etc. In these cases, you have two approaches you can use: Split your controller into separate responsibilities, and use the more specific controllers. This way you don't need to inject dependencies that are only used in some actions. (We recommend doing this regardless, as it helps keep your code more maintainable.) Use lazy services . When you configure these, laminas-servicemanager gives you a proxy instance that, on first access, loads the full service. This allows you to delay the most expensive operations until absolutely needed.","title":"v2.X to v2.7"},{"location":"migration/to-v2-7/#upgrading-to-27","text":"","title":"Upgrading to 2.7"},{"location":"migration/to-v2-7/#middleware","text":"laminas-mvc now registers Laminas\\Mvc\\MiddlewareListener as a dispatch listener at a priority higher than Laminas\\Mvc\\DispatchListener , allowing dispatch of PSR-7 middleware. Read the middleware chapter for details on how to use this new feature.","title":"Middleware"},{"location":"migration/to-v2-7/#application","text":"The constructor signature of Laminas\\Mvc\\Application has changed. Previously, it was: __construct($configuration, ServiceManager $serviceManager) and internally, it pulled the services EventManager , Request , and Response from the provided $serviceManager during initialization. The new constructor signature provides optional arguments for injecting the event manager, request, and response: __construct( $configuration, ServiceManager $serviceManager, EventManager $events = null, RequestInterface $request = null, ResponseInterface $response = null ) This change makes all dependencies explicit. Starting in v3.0, the new arguments will be required . The factory Laminas\\Mvc\\Service\\ApplicationFactory was updated to follow the new signature. This change should only affect users who are manually instantiating the Application instance.","title":"Application"},{"location":"migration/to-v2-7/#eventmanageraware-initializers","text":"laminas-mvc provides two mechanisms for injecting event managers into EventManagerAware objects. One is the \"EventManagerAwareInitializer\" registered in Laminas\\Mvc\\Service\\ServiceManagerConfig , and the other is the Laminas\\Mvc\\Controller\\ControllerManager::injectEventManager() initializer. In both cases, the logic was updated to be forwards compatible with laminas-eventmanager v3. Previously each would check if the instance's getEventManager() method returned an event manager instance, and, if so, inject the shared event manager: $events = $instance-&gt;getEventManager(); if ($events instanceof EventManagerInterface) { $events-&gt;setSharedManager($container-&gt;get('SharedEventManager')); } In laminas-eventmanager v3, event managers are now injected with the shared manager at instantiation, and no setter exists for providing the shared manager. As such, the above logic changed to: $events = $instance-&gt;getEventManager(); if (! $events || ! $events-&gt;getSharedManager()) { $instance-&gt;setEventManager($container-&gt;get('EventManager')); } In other words, it re-injects with a new event manager instance if the instance pulled does not have a shared manager composed. This likely will not cause regressions in existing code, but may be something to be aware of if you were previously depending on lazy-loaded event manager state.","title":"EventManagerAware initializers"},{"location":"migration/to-v2-7/#servicelocatoraware-initializers","text":"laminas-servicemanager v3.0 removes Laminas\\ServiceManager\\ServiceLocatorAwareInterface . Since laminas-mvc provides initializers around that interface, they needed updates to allow both forwards compatibility with laminas-servicemanager v3 as well as backwards compatibility with existing applications. This was accomplished in two ways: The abstract controller implementations no longer implement ServiceLocatorAwareInterface , but continue to define the methods that the interface defines (namely setServiceLocator() and getServiceLocator() . The initializers registered by Laminas\\Mvc\\Service\\ServiceManagerConfig and Laminas\\Mvc\\Controller\\ControllerManager now use duck-typing to determine if an instance requires container injection; if so it will do so. However, we also maintain that service locator injection is an anti-pattern; dependencies should be injected directly into instances instead. As such, starting in 2.7.0, we now emit a deprecation notice any time an instance is injected by one of these initializers, and we plan to remove the initializers for version 3.0. The deprecation notice includes the name of the class, to help you identify what instances you will need to update before the laminas-mvc v3 release. To prepare your code, you will need to do the following within your controller: Find all cases where you call getServiceLocator() , and identify the services they retrieve. Update your controller to accept these services via the constructor. If you have not already, create a factory class for your controller. In the factory, pull the appropriate services and pass them to the controller's constructor. As an example, consider the following code from a controller: $db = $this-&gt;getServiceLcoator()-&gt;get('Db\\ApplicationAdapter'); To update your controller, you will: Add a $db property to your class. Update the constructor to accept the database adapter and assign it to the $db property. Change the above line to either read $db = $this-&gt;db; or just use the property directly . Add a factory that pulls the service and pushes it into the controller. The controller then might look like the following: use Laminas\\Db\\Adapter\\AdapterInterface; use Laminas\\Mvc\\Controller\\AbstractActionController; class YourController extends AbstractActionController { private $db; public function __construct(AdapterInterface $db) { $this-&gt;db = $db; } public function someAction() { $results = $this-&gt;db-&gt;query(/* ... */); /* ... */ } } A factory would look like the following: use Interop\\Container\\ContainerInterface; class YourControllerFactory { public function __invoke(ContainerInterface $container) { return new YourController($container-&gt;get('Db\\ApplicationAdapter')); } } You then also need to ensure the controller manager knows about the factory. It likely already does, as an invokable; you will redefine it as a factory in your module.config.php : return [ 'controllers' =&gt; [ 'factories' =&gt; [ YourController::class =&gt; YourControllerFactory::class, /* ... */ ], /* ... */ ], /* ... */ ]; While this may seem like more steps, doing so ensures your code has no hidden dependencies, improves the testability of your code, and allows you to substitute alternatives for either the dependencies or the controller itself.","title":"ServiceLocatorAware initializers"},{"location":"migration/to-v3-0/","text":"Upgrading to 3.0 With the release of Laminas, all components current at that time, regardless of history, were tagged as v2 releases; in reality, it was the first version of a new framework, as it was a completely new architecture from Laminas Framework 1. As such, laminas-mvc 3.0 marks the second major release of the component. The primary goal for version 3 was to reduce the number of dependencies, and to split out unrelated, tangential, or extension functionality. As such, there are a number of changes that will impact users. Dependency reduction In order to remove dependencies, we needed to provide alternate ways to ensure that default functionality, such as service registration and event listener attachment, could still occur. The solution to this problem was to expose each component as a module. This however, raised another problem: you now have to register components as modules in your application. To solve this new problem, we created a new component, laminas-component-installer . Install this in your application now: $ composer require --dev laminas/laminas-component-installer Once installed, the component acts as a Composer plugin, and will intercept packages marked as components or Laminas modules, and register them with your application configuration. Components are pushed to the top of the module list, while modules are pushed to the end. As a development component, it will not be installed in your production distributions. Updated dependencies The v3 release now requires : laminas-http laminas-modulemanager laminas-router laminas-view Additionally, the following components require their v3 releases: laminas-eventmanager laminas-servicemanager laminas-stdlib The minimum supported PHP version was bumped to 5.6. Application class The following changes were made to the Laminas\\Mvc\\Application constructor: The first $configuration argument was removed, as it was not used. Three additional, optional arguments were added: Laminas\\EventManager\\EventManagerInterface $events = null Laminas\\Stdlib\\RequestInterface $request = null Laminas\\Stdlib\\ResponseInterface $response = null End-users using the skeleton application and the default Application factory will not notice a change. Those who are directly instantiating the Application instance (in production or test code) or who have created their own factory for the class will need to update their code. send method The send() method has been deprecated since the 2.2 release, and a no-op since then as well. It is removed starting with the v3 release. ControllerLoader The ControllerLoader service was deprecated early in the v2 lifecycle, and aliased to ControllerManager . The ControllerLoader factory was kept to prevent BC breaks due to extending the class. v3 removes the ControllerLoaderFactory , as well as the ControllerLoader service alias. DI-ServiceManager integration The integration between laminas-servicemanager and laminas-di has been moved to a new standalone component, laminas-servicemanager-di . In most cases, installing the component will restore the original behavior: $ composer require laminas/laminas-servicemanager-di Manual installation The above assumes you're using the new component installer detailed in the dependency reduction section, above. If you are not, you will need to inject the laminas-servicemanager-di module into your application manually; follow the instructions in the laminas-servicemanager-di documentation to do so. The new component also contains a migration document detailing potential issues for users migrating to version 3. DispatchListener The marshallControllerNotFoundEvent() method was deprecated early in the Laminas lifecycle, and has proxied to marshalControllerNotFoundEvent() . It is removed with the v3 release. Routing Routing was removed from laminas-mvc, and moved to a new component, laminas-router , which is now a dependency of laminas-mvc. The changes that will impact users are: Query route removal ; this route had been deprecated since 2.3.0, and removed for the 3.0 release. Namespace changes ; with the separation to the laminas-router component, all routes changed namespaces from Laminas\\Mvc\\Router to Laminas\\Router . Follow the links above for more details on these changes, and how to migrate your code. Console tooling Console tooling, including console routes, were split off to a new component, laminas-mvc-console . If you were using the console tooling, install laminas-mvc-console: $ composer require laminas/laminas-mvc-console (Make sure you've already installed laminas-component-installer before you do, to ensure the component is registered with your application!) laminas-mvc-console exposes all of the same functionality as was in the v2 series of laminas-mvc, but most components are in different namespaces. Please read the laminas-mvc-console migration guide for full details of what changes you may need to make to your application to ensure console tooling continues to work. Migrate your console tooling Due to the amount of integration required to support console tooling via the MVC, we do not plan on supporting laminas-mvc-console long-term. As such, we recommend migrating your code to use standalone tools such as zf-console or Aura.Cli . Filter integration In version 2, laminas-mvc exposed a FilterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide filter configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-filter component itself. To add it, install laminas-filter: $ composer require laminas/laminas-filter Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . Form integration In version 2, laminas-mvc exposed several facilities related to laminas-form: FormElementManager mapped to a factory in laminas-mvc, but created a Laminas\\Form\\FormElementManager instance. FormAnnotationBuilder mapped to a factory in laminas-mvc, but created a Laminas\\Form\\Annotation\\AnnotationBuilder instance. The ServiceListenerFactory registered Laminas\\Form\\FormAbstractServiceFactory as an abstract factory. The ModuleManagerFactory registered specifications with the laminas-modulemanager ServiceListener to allow modules to provide form element configuration. The above functionality is now removed from laminas-mvc, and exposed directly by the laminas-form component. To add/enable it, install laminas-form: $ composer require laminas/laminas-form Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . Hydrator integration In version 2, laminas-mvc exposed a HydratorManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide hydrator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-hydrator component itself. To add it, install laminas-hydrator: $ composer require laminas/laminas-hydrator Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . InputFilter integration In version 2, laminas-mvc exposed a InputFilterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide validator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-inputfilter component itself. To add it, install laminas-inputfilter: $ composer require laminas/laminas-inputfilter Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . laminas-inputfilter now also exposes the InputFilterAbstractServiceFactory as an abstract factory by default. i18n integration Internationalization tooling, including: the integration translator ( MvcTranslator service) the \"dummy\" translator the TranslatorAwareTreeRouteStack implementation factories for the translator and translator loader managers were removed, and re-assigned to the laminas-i18n and laminas-mvc-i18n packages. In most cases, you can install laminas/laminas-mvc-i18n to restore i18n functionality to your application: $ composer require laminas/laminas-mvc-i18n There are two categories of changes that could affect you on upgrading. First, if you were using the TranslatorAwareTreeRouteStack , the class name has changed from Laminas\\Mvc\\Router\\Http\\TranslatorAwareTreeRouteStack to Laminas\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack ; updating your code to reflect that will allow it to work again. Second, if you were extending one of the service factories for either the MvcTranslator or the TranslatorPluginManager , the namespaces for the factories have changed. In such situations, you have two options: Update your extensions to extend the new classes. See the laminas-mvc-i18n migration guide to determine what names have changed. Instead of extending, consider using delegator factories , as these decorate the service factory, regardless of what factory is used. Log integration In version 2, laminas-mvc exposed LogProcessorManager and LogWriterManager services by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide configuration for each. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-log component itself. To add it, install laminas-log: $ composer require laminas/laminas-log Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . laminas-log now also exposes LogFilterManager and LogFormatterManager , corresponding to the following: Service Config Key Provider Interface Provider Method LogFilterManager log_filters Laminas\\Log\\Filter\\LogFilterProviderInterface getLogFilterConfig() LogFormatterManager log_formatters Laminas\\Log\\Formatter\\LogFormatterProviderInterface getLogFormatterConfig() This additions allow you to provide additional plugins for every aspect laminas-log exposes. Plugins The following plugins have been removed from the main laminas-mvc repository, and into their own standalone repositories. In all cases, please be sure to install the component installer as detailed above before installing the plugins, to automate injection into your application configuration. fileprg() The fileprg() plugin is now provided via the laminas-mvc-plugin-fileprg component. $ composer require laminas/laminas-mvc-plugin-fileprg Laminas\\Mvc\\Controller\\Plugin\\FilePostRedirectGet becomes Laminas\\Mvc\\Plugin\\FilePrg\\FilePostRedirectGet . However, it is still mapped as fileprg() . flashMessenger() The flashMessenger() plugin is now provided via the laminas-mvc-plugin-flashmessenger component. $ composer require laminas/laminas-mvc-plugin-flashmessenger Laminas\\Mvc\\Controller\\Plugin\\FlashMessenger becomes Laminas\\Mvc\\Plugin\\FlashMessenger\\FlashMessenger . However, it is still mapped as flashMessenger() and flashmessenger() . identity() The identity() plugin is now provided via the laminas-mvc-plugin-identity component. $ composer require laminas/laminas-mvc-plugin-identity Laminas\\Mvc\\Controller\\Plugin\\Identity becomes Laminas\\Mvc\\Plugin\\Identity\\Identity . However, it is still mapped as identity() . Additionally, Laminas\\Mvc\\Controller\\Plugin\\Service\\IdentityFactory now becomes Laminas\\Mvc\\Plugin\\Identity\\IdentityFactory . prg() The prg() plugin is now provided via the laminas-mvc-plugin-prg component. $ composer require laminas/laminas-mvc-plugin-prg Laminas\\Mvc\\Controller\\Plugin\\PostRedirectGet becomes Laminas\\Mvc\\Plugin\\Prg\\PostRedirectGet . However, it is still mapped as prg() . Serializer integration In version 2, laminas-mvc exposed a SerializerAdapterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide serializer configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-serializer component itself. To add it, install laminas-serializer $ composer require laminas/laminas-serializer Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . ServiceLocatorAware initializers Starting with laminas-servicemanager v3, that component no longer defines the ServiceLocatorAwareInterface . Since laminas-mvc pins against laminas-servicemanager v3 with its own v3 release, the initializers that injected the application container into implementations of that interface are no longer relevant. As such, they have now been removed from each of the Laminas\\Mvc\\Service\\ServiceManagerConfig and Laminas\\Mvc\\Controller\\ControllerManager classes. Additionally, the duck-typed ServiceLocatorAwareInterface implementation in AbstractController was removed, as messaged in the 2.7 release. If you relied on this functionality, you are encouraged to update your code to use factories to inject your actual dependencies. Validator integration In version 2, laminas-mvc exposed a ValidatorManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide validator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-validator component itself. To add it, install laminas-validator: $ composer require laminas/laminas-validator Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . Laminas\\Mvc\\View\\InjectTemplateListener The InjectTemplateListener attempts to map a controller name to a template using a variety of heuristics, including an explicit map provided during configuration, or auto-detection based on the controller class name. In version 2, the autodetection took into consideration the __NAMESPACE__ route match parameter to derive subnamespaces, or would omit them completely if __NAMESPACE__ was not present. This caused issues when multiple modules shared a top-level namespace (e.g., Laminas\\ApiTools and Laminas\\ApiTools\\Admin ) and each had a controller with the same name. To avoid naming conflicts, version 3 removes this aspect of autodetection, and instead provides exactly one workflow for mapping: Strip the Controller subnamespace, if present (e.g., the namespace Application\\Controller\\\\ is normalized to Application\\\\ ). Strip the Controller suffix in the class name, if present (e.g., IndexController is normalized to Index ). Inflect CamelCasing to dash-separated (e.g., ShowUsers becomes show-users ). Replace the namespace separator with a slash. As a full example, the controller service name TestSomething\\With\\Controller\\CamelCaseController will always map to test-something/with/camel-case , regardless of the __NAMESPACE__ value provided in routing configuration. If needed, you can emulate the version 2 behavior in version 3 via namespace whitelisting in the controller &lt;=&gt; template map. Laminas\\Mvc\\View\\SendResponseListener Laminas\\Mvc\\View\\SendResponseListener was deprecated with the 2.2 release, and has been an extension of Laminas\\Mvc\\SendResponseListener ever since. It is removed with the v3 release.","title":"v2.X to v3.0"},{"location":"migration/to-v3-0/#upgrading-to-30","text":"With the release of Laminas, all components current at that time, regardless of history, were tagged as v2 releases; in reality, it was the first version of a new framework, as it was a completely new architecture from Laminas Framework 1. As such, laminas-mvc 3.0 marks the second major release of the component. The primary goal for version 3 was to reduce the number of dependencies, and to split out unrelated, tangential, or extension functionality. As such, there are a number of changes that will impact users.","title":"Upgrading to 3.0"},{"location":"migration/to-v3-0/#dependency-reduction","text":"In order to remove dependencies, we needed to provide alternate ways to ensure that default functionality, such as service registration and event listener attachment, could still occur. The solution to this problem was to expose each component as a module. This however, raised another problem: you now have to register components as modules in your application. To solve this new problem, we created a new component, laminas-component-installer . Install this in your application now: $ composer require --dev laminas/laminas-component-installer Once installed, the component acts as a Composer plugin, and will intercept packages marked as components or Laminas modules, and register them with your application configuration. Components are pushed to the top of the module list, while modules are pushed to the end. As a development component, it will not be installed in your production distributions.","title":"Dependency reduction"},{"location":"migration/to-v3-0/#updated-dependencies","text":"The v3 release now requires : laminas-http laminas-modulemanager laminas-router laminas-view Additionally, the following components require their v3 releases: laminas-eventmanager laminas-servicemanager laminas-stdlib The minimum supported PHP version was bumped to 5.6.","title":"Updated dependencies"},{"location":"migration/to-v3-0/#application-class","text":"The following changes were made to the Laminas\\Mvc\\Application constructor: The first $configuration argument was removed, as it was not used. Three additional, optional arguments were added: Laminas\\EventManager\\EventManagerInterface $events = null Laminas\\Stdlib\\RequestInterface $request = null Laminas\\Stdlib\\ResponseInterface $response = null End-users using the skeleton application and the default Application factory will not notice a change. Those who are directly instantiating the Application instance (in production or test code) or who have created their own factory for the class will need to update their code.","title":"Application class"},{"location":"migration/to-v3-0/#controllerloader","text":"The ControllerLoader service was deprecated early in the v2 lifecycle, and aliased to ControllerManager . The ControllerLoader factory was kept to prevent BC breaks due to extending the class. v3 removes the ControllerLoaderFactory , as well as the ControllerLoader service alias.","title":"ControllerLoader"},{"location":"migration/to-v3-0/#di-servicemanager-integration","text":"The integration between laminas-servicemanager and laminas-di has been moved to a new standalone component, laminas-servicemanager-di . In most cases, installing the component will restore the original behavior: $ composer require laminas/laminas-servicemanager-di","title":"DI-ServiceManager integration"},{"location":"migration/to-v3-0/#dispatchlistener","text":"The marshallControllerNotFoundEvent() method was deprecated early in the Laminas lifecycle, and has proxied to marshalControllerNotFoundEvent() . It is removed with the v3 release.","title":"DispatchListener"},{"location":"migration/to-v3-0/#routing","text":"Routing was removed from laminas-mvc, and moved to a new component, laminas-router , which is now a dependency of laminas-mvc. The changes that will impact users are: Query route removal ; this route had been deprecated since 2.3.0, and removed for the 3.0 release. Namespace changes ; with the separation to the laminas-router component, all routes changed namespaces from Laminas\\Mvc\\Router to Laminas\\Router . Follow the links above for more details on these changes, and how to migrate your code.","title":"Routing"},{"location":"migration/to-v3-0/#console-tooling","text":"Console tooling, including console routes, were split off to a new component, laminas-mvc-console . If you were using the console tooling, install laminas-mvc-console: $ composer require laminas/laminas-mvc-console (Make sure you've already installed laminas-component-installer before you do, to ensure the component is registered with your application!) laminas-mvc-console exposes all of the same functionality as was in the v2 series of laminas-mvc, but most components are in different namespaces. Please read the laminas-mvc-console migration guide for full details of what changes you may need to make to your application to ensure console tooling continues to work.","title":"Console tooling"},{"location":"migration/to-v3-0/#filter-integration","text":"In version 2, laminas-mvc exposed a FilterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide filter configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-filter component itself. To add it, install laminas-filter: $ composer require laminas/laminas-filter Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction .","title":"Filter integration"},{"location":"migration/to-v3-0/#form-integration","text":"In version 2, laminas-mvc exposed several facilities related to laminas-form: FormElementManager mapped to a factory in laminas-mvc, but created a Laminas\\Form\\FormElementManager instance. FormAnnotationBuilder mapped to a factory in laminas-mvc, but created a Laminas\\Form\\Annotation\\AnnotationBuilder instance. The ServiceListenerFactory registered Laminas\\Form\\FormAbstractServiceFactory as an abstract factory. The ModuleManagerFactory registered specifications with the laminas-modulemanager ServiceListener to allow modules to provide form element configuration. The above functionality is now removed from laminas-mvc, and exposed directly by the laminas-form component. To add/enable it, install laminas-form: $ composer require laminas/laminas-form Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction .","title":"Form integration"},{"location":"migration/to-v3-0/#hydrator-integration","text":"In version 2, laminas-mvc exposed a HydratorManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide hydrator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-hydrator component itself. To add it, install laminas-hydrator: $ composer require laminas/laminas-hydrator Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction .","title":"Hydrator integration"},{"location":"migration/to-v3-0/#inputfilter-integration","text":"In version 2, laminas-mvc exposed a InputFilterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide validator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-inputfilter component itself. To add it, install laminas-inputfilter: $ composer require laminas/laminas-inputfilter Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . laminas-inputfilter now also exposes the InputFilterAbstractServiceFactory as an abstract factory by default.","title":"InputFilter integration"},{"location":"migration/to-v3-0/#i18n-integration","text":"Internationalization tooling, including: the integration translator ( MvcTranslator service) the \"dummy\" translator the TranslatorAwareTreeRouteStack implementation factories for the translator and translator loader managers were removed, and re-assigned to the laminas-i18n and laminas-mvc-i18n packages. In most cases, you can install laminas/laminas-mvc-i18n to restore i18n functionality to your application: $ composer require laminas/laminas-mvc-i18n There are two categories of changes that could affect you on upgrading. First, if you were using the TranslatorAwareTreeRouteStack , the class name has changed from Laminas\\Mvc\\Router\\Http\\TranslatorAwareTreeRouteStack to Laminas\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack ; updating your code to reflect that will allow it to work again. Second, if you were extending one of the service factories for either the MvcTranslator or the TranslatorPluginManager , the namespaces for the factories have changed. In such situations, you have two options: Update your extensions to extend the new classes. See the laminas-mvc-i18n migration guide to determine what names have changed. Instead of extending, consider using delegator factories , as these decorate the service factory, regardless of what factory is used.","title":"i18n integration"},{"location":"migration/to-v3-0/#log-integration","text":"In version 2, laminas-mvc exposed LogProcessorManager and LogWriterManager services by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide configuration for each. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-log component itself. To add it, install laminas-log: $ composer require laminas/laminas-log Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . laminas-log now also exposes LogFilterManager and LogFormatterManager , corresponding to the following: Service Config Key Provider Interface Provider Method LogFilterManager log_filters Laminas\\Log\\Filter\\LogFilterProviderInterface getLogFilterConfig() LogFormatterManager log_formatters Laminas\\Log\\Formatter\\LogFormatterProviderInterface getLogFormatterConfig() This additions allow you to provide additional plugins for every aspect laminas-log exposes.","title":"Log integration"},{"location":"migration/to-v3-0/#plugins","text":"The following plugins have been removed from the main laminas-mvc repository, and into their own standalone repositories. In all cases, please be sure to install the component installer as detailed above before installing the plugins, to automate injection into your application configuration.","title":"Plugins"},{"location":"migration/to-v3-0/#serializer-integration","text":"In version 2, laminas-mvc exposed a SerializerAdapterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide serializer configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-serializer component itself. To add it, install laminas-serializer $ composer require laminas/laminas-serializer Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction .","title":"Serializer integration"},{"location":"migration/to-v3-0/#servicelocatoraware-initializers","text":"Starting with laminas-servicemanager v3, that component no longer defines the ServiceLocatorAwareInterface . Since laminas-mvc pins against laminas-servicemanager v3 with its own v3 release, the initializers that injected the application container into implementations of that interface are no longer relevant. As such, they have now been removed from each of the Laminas\\Mvc\\Service\\ServiceManagerConfig and Laminas\\Mvc\\Controller\\ControllerManager classes. Additionally, the duck-typed ServiceLocatorAwareInterface implementation in AbstractController was removed, as messaged in the 2.7 release. If you relied on this functionality, you are encouraged to update your code to use factories to inject your actual dependencies.","title":"ServiceLocatorAware initializers"},{"location":"migration/to-v3-0/#validator-integration","text":"In version 2, laminas-mvc exposed a ValidatorManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide validator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-validator component itself. To add it, install laminas-validator: $ composer require laminas/laminas-validator Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction .","title":"Validator integration"},{"location":"migration/to-v3-0/#laminasmvcviewinjecttemplatelistener","text":"The InjectTemplateListener attempts to map a controller name to a template using a variety of heuristics, including an explicit map provided during configuration, or auto-detection based on the controller class name. In version 2, the autodetection took into consideration the __NAMESPACE__ route match parameter to derive subnamespaces, or would omit them completely if __NAMESPACE__ was not present. This caused issues when multiple modules shared a top-level namespace (e.g., Laminas\\ApiTools and Laminas\\ApiTools\\Admin ) and each had a controller with the same name. To avoid naming conflicts, version 3 removes this aspect of autodetection, and instead provides exactly one workflow for mapping: Strip the Controller subnamespace, if present (e.g., the namespace Application\\Controller\\\\ is normalized to Application\\\\ ). Strip the Controller suffix in the class name, if present (e.g., IndexController is normalized to Index ). Inflect CamelCasing to dash-separated (e.g., ShowUsers becomes show-users ). Replace the namespace separator with a slash. As a full example, the controller service name TestSomething\\With\\Controller\\CamelCaseController will always map to test-something/with/camel-case , regardless of the __NAMESPACE__ value provided in routing configuration. If needed, you can emulate the version 2 behavior in version 3 via namespace whitelisting in the controller &lt;=&gt; template map.","title":"Laminas\\Mvc\\View\\InjectTemplateListener"},{"location":"migration/to-v3-0/#laminasmvcviewsendresponselistener","text":"Laminas\\Mvc\\View\\SendResponseListener was deprecated with the 2.2 release, and has been an extension of Laminas\\Mvc\\SendResponseListener ever since. It is removed with the v3 release.","title":"Laminas\\Mvc\\View\\SendResponseListener"}]}